// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: params.proto

package org.arbeitspferde.groningen.proto;

public final class Params {
  private Params() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  public interface GroningenParamsOrBuilder
      extends com.google.protobuf.MessageOrBuilder {

    // optional string input_log_name = 1;
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    boolean hasInputLogName();
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    java.lang.String getInputLogName();
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    com.google.protobuf.ByteString
        getInputLogNameBytes();

    // optional int32 duration = 2 [default = 1440];
    /**
     * <code>optional int32 duration = 2 [default = 1440];</code>
     *
     * <pre>
     * time in minutes that the experiments run in production
     * </pre>
     */
    boolean hasDuration();
    /**
     * <code>optional int32 duration = 2 [default = 1440];</code>
     *
     * <pre>
     * time in minutes that the experiments run in production
     * </pre>
     */
    int getDuration();

    // optional int32 restart = 3 [default = 4];
    /**
     * <code>optional int32 restart = 3 [default = 4];</code>
     *
     * <pre>
     * experimental subject restart threshold used by the Executor and Validator
     * </pre>
     */
    boolean hasRestart();
    /**
     * <code>optional int32 restart = 3 [default = 4];</code>
     *
     * <pre>
     * experimental subject restart threshold used by the Executor and Validator
     * </pre>
     */
    int getRestart();

    // optional double latency_weight = 5 [default = 1];
    /**
     * <code>optional double latency_weight = 5 [default = 1];</code>
     *
     * <pre>
     * Weight of the latency score within the hypothesizer
     * </pre>
     */
    boolean hasLatencyWeight();
    /**
     * <code>optional double latency_weight = 5 [default = 1];</code>
     *
     * <pre>
     * Weight of the latency score within the hypothesizer
     * </pre>
     */
    double getLatencyWeight();

    // optional double throughput_weight = 6 [default = 1];
    /**
     * <code>optional double throughput_weight = 6 [default = 1];</code>
     *
     * <pre>
     * Weight of the throughput score within the hypothesizer
     * </pre>
     */
    boolean hasThroughputWeight();
    /**
     * <code>optional double throughput_weight = 6 [default = 1];</code>
     *
     * <pre>
     * Weight of the throughput score within the hypothesizer
     * </pre>
     */
    double getThroughputWeight();

    // optional double memory_weight = 8 [default = 1];
    /**
     * <code>optional double memory_weight = 8 [default = 1];</code>
     *
     * <pre>
     * Weight of the memory score within the hypothesizer
     * </pre>
     */
    boolean hasMemoryWeight();
    /**
     * <code>optional double memory_weight = 8 [default = 1];</code>
     *
     * <pre>
     * Weight of the memory score within the hypothesizer
     * </pre>
     */
    double getMemoryWeight();

    // optional int32 num_crossovers = 9 [default = 1];
    /**
     * <code>optional int32 num_crossovers = 9 [default = 1];</code>
     *
     * <pre>
     * Number cross-over points for mating within hypothesizer
     * </pre>
     */
    boolean hasNumCrossovers();
    /**
     * <code>optional int32 num_crossovers = 9 [default = 1];</code>
     *
     * <pre>
     * Number cross-over points for mating within hypothesizer
     * </pre>
     */
    int getNumCrossovers();

    // optional double mutation_prob = 10 [default = 0.02];
    /**
     * <code>optional double mutation_prob = 10 [default = 0.02];</code>
     *
     * <pre>
     * Mutation probability for the offsprings
     * </pre>
     */
    boolean hasMutationProb();
    /**
     * <code>optional double mutation_prob = 10 [default = 0.02];</code>
     *
     * <pre>
     * Mutation probability for the offsprings
     * </pre>
     */
    double getMutationProb();

    // optional int32 stagnant_gens = 11 [default = 0];
    /**
     * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
     *
     * <pre>
     * Number of stagnant generations before GA terminates. The value 0 disables
     * this termination condition check.
     * </pre>
     */
    boolean hasStagnantGens();
    /**
     * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
     *
     * <pre>
     * Number of stagnant generations before GA terminates. The value 0 disables
     * this termination condition check.
     * </pre>
     */
    int getStagnantGens();

    // optional int32 elite_count = 12 [default = 1];
    /**
     * <code>optional int32 elite_count = 12 [default = 1];</code>
     *
     * <pre>
     * Number of elite individuals in the populations for the
     *  IncrementalEvolutionEngine
     * NOTE: is not updated after the initial pass through the loop.
     * </pre>
     */
    boolean hasEliteCount();
    /**
     * <code>optional int32 elite_count = 12 [default = 1];</code>
     *
     * <pre>
     * Number of elite individuals in the populations for the
     *  IncrementalEvolutionEngine
     * NOTE: is not updated after the initial pass through the loop.
     * </pre>
     */
    int getEliteCount();

    // optional double pause_time_latency_score_percentile = 13 [default = 99];
    /**
     * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
     *
     * <pre>
     * The percentile used to compute the latency score (A value from 0 to 100)
     * </pre>
     */
    boolean hasPauseTimeLatencyScorePercentile();
    /**
     * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
     *
     * <pre>
     * The percentile used to compute the latency score (A value from 0 to 100)
     * </pre>
     */
    double getPauseTimeLatencyScorePercentile();

    // optional int32 number_of_executor_threads = 14 [default = 3];
    /**
     * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
     *
     * <pre>
     * The number of threads that the Executor uses to monitor experimental
     * subjects.  Quite likely, you'll want to increase this as you increase the
     * total number of subjects in your experiment. Less threads probably implies
     * alonger period of time between sucessive probes of a given experimental
     * subject.
     * </pre>
     */
    boolean hasNumberOfExecutorThreads();
    /**
     * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
     *
     * <pre>
     * The number of threads that the Executor uses to monitor experimental
     * subjects.  Quite likely, you'll want to increase this as you increase the
     * total number of subjects in your experiment. Less threads probably implies
     * alonger period of time between sucessive probes of a given experimental
     * subject.
     * </pre>
     */
    int getNumberOfExecutorThreads();

    // optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];
    /**
     * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
     */
    boolean hasPipelineSyncType();
    /**
     * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
     */
    org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode getPipelineSyncType();

    // optional int32 health_check_timeout = 16 [default = 30000];
    /**
     * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
     *
     * <pre>
     * How long we wait for a health check check
     * </pre>
     */
    boolean hasHealthCheckTimeout();
    /**
     * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
     *
     * <pre>
     * How long we wait for a health check check
     * </pre>
     */
    int getHealthCheckTimeout();

    // optional int32 health_check_poll_interval = 17 [default = 5000];
    /**
     * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
     *
     * <pre>
     * How long we sleep between health checks.
     * </pre>
     */
    boolean hasHealthCheckPollInterval();
    /**
     * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
     *
     * <pre>
     * How long we sleep between health checks.
     * </pre>
     */
    int getHealthCheckPollInterval();

    // optional string health_check_server_type = 18 [default = ""];
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    boolean hasHealthCheckServerType();
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    java.lang.String getHealthCheckServerType();
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    com.google.protobuf.ByteString
        getHealthCheckServerTypeBytes();

    // optional int32 metric_query_deadline_secs = 19 [default = 3];
    /**
     * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
     *
     * <pre>
     * The default deadline in seconds for metric queries.
     * </pre>
     */
    boolean hasMetricQueryDeadlineSecs();
    /**
     * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
     *
     * <pre>
     * The default deadline in seconds for metric queries.
     * </pre>
     */
    int getMetricQueryDeadlineSecs();

    // optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];
    /**
     * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
     *
     * <pre>
     * The default channel TTL in seconds for metric query channel.
     * </pre>
     */
    boolean hasMetricQueryChannelShutdownDelaySecs();
    /**
     * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
     *
     * <pre>
     * The default channel TTL in seconds for metric query channel.
     * </pre>
     */
    int getMetricQueryChannelShutdownDelaySecs();

    // optional int32 metric_query_retry_maximum_count = 21 [default = 3];
    /**
     * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
     *
     * <pre>
     * The maximum number of times the metric query pipeline will attempt to query.
     * </pre>
     */
    boolean hasMetricQueryRetryMaximumCount();
    /**
     * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
     *
     * <pre>
     * The maximum number of times the metric query pipeline will attempt to query.
     * </pre>
     */
    int getMetricQueryRetryMaximumCount();

    // optional int32 metric_query_retry_delay_secs = 22 [default = 2];
    /**
     * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
     *
     * <pre>
     * The initial delay in seconds between retries for metric query failures.
     * </pre>
     */
    boolean hasMetricQueryRetryDelaySecs();
    /**
     * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
     *
     * <pre>
     * The initial delay in seconds between retries for metric query failures.
     * </pre>
     */
    int getMetricQueryRetryDelaySecs();

    // optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];
    /**
     * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
     *
     * <pre>
     * Deadline (ms) of how long to wait for a subject to restart.
     * </pre>
     */
    boolean hasExecutorWaitForOneSubjectRestartMs();
    /**
     * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
     *
     * <pre>
     * Deadline (ms) of how long to wait for a subject to restart.
     * </pre>
     */
    int getExecutorWaitForOneSubjectRestartMs();

    // optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];
    /**
     * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
     *
     * <pre>
     * Interval (ms) we wait between an iteration of polling subjects
     * </pre>
     */
    boolean hasExecutorSleepBtwnPollingMetricsMs();
    /**
     * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
     *
     * <pre>
     * Interval (ms) we wait between an iteration of polling subjects
     * </pre>
     */
    int getExecutorSleepBtwnPollingMetricsMs();

    // optional int32 extractor_number_of_extractor_threads = 25 [default = 10];
    /**
     * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
     *
     * <pre>
     * The number of extractor threads.
     * </pre>
     */
    boolean hasExtractorNumberOfExtractorThreads();
    /**
     * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
     *
     * <pre>
     * The number of extractor threads.
     * </pre>
     */
    int getExtractorNumberOfExtractorThreads();

    // optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];
    /**
     * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
     *
     * <pre>
     * Maximum number of subjects to restart at once.
     * </pre>
     */
    boolean hasMaximumInflightSubjectRestartCount();
    /**
     * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
     *
     * <pre>
     * Maximum number of subjects to restart at once.
     * </pre>
     */
    int getMaximumInflightSubjectRestartCount();

    // optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];
    /**
     * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
     *
     * <pre>
     * The deadline (ms) for subject manipulation to occur.
     * </pre>
     */
    boolean hasSubjectManipulationDeadlineMs();
    /**
     * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
     *
     * <pre>
     * The deadline (ms) for subject manipulation to occur.
     * </pre>
     */
    int getSubjectManipulationDeadlineMs();

    // optional string checkpoint_file = 28 [default = ""];
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    boolean hasCheckpointFile();
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    java.lang.String getCheckpointFile();
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    com.google.protobuf.ByteString
        getCheckpointFileBytes();

    // optional int32 default_in_memory_cache_ttl = 29 [default = 600000];
    /**
     * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
     *
     * <pre>
     * The maximum TTL in seconds for objects in the memory-sensitive caches.
     * </pre>
     */
    boolean hasDefaultInMemoryCacheTtl();
    /**
     * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
     *
     * <pre>
     * The maximum TTL in seconds for objects in the memory-sensitive caches.
     * </pre>
     */
    int getDefaultInMemoryCacheTtl();

    // optional int32 max_subjects_in_flight_fraction = 30 [default = 3];
    /**
     * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
     *
     * <pre>
     * Divisor for max subjects in-flight for rolling subject group restart.
     * (maxInFlight = # subjects / this divisor)
     * </pre>
     */
    boolean hasMaxSubjectsInFlightFraction();
    /**
     * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
     *
     * <pre>
     * Divisor for max subjects in-flight for rolling subject group restart.
     * (maxInFlight = # subjects / this divisor)
     * </pre>
     */
    int getMaxSubjectsInFlightFraction();

    // optional int32 subject_group_number_of_shuffles = 31 [default = 8];
    /**
     * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
     *
     * <pre>
     * The number of times to shuffle the subjects.
     * </pre>
     */
    boolean hasSubjectGroupNumberOfShuffles();
    /**
     * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
     *
     * <pre>
     * The number of times to shuffle the subjects.
     * </pre>
     */
    int getSubjectGroupNumberOfShuffles();

    // optional int32 subjects_to_display = 32 [default = 5];
    /**
     * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
     *
     * <pre>
     * The number of subjects to display in Groningen's HUD.
     * </pre>
     */
    boolean hasSubjectsToDisplay();
    /**
     * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
     *
     * <pre>
     * The number of subjects to display in Groningen's HUD.
     * </pre>
     */
    int getSubjectsToDisplay();

    // optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    boolean hasEventLogPrefix();
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    java.lang.String getEventLogPrefix();
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    com.google.protobuf.ByteString
        getEventLogPrefixBytes();

    // optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];
    /**
     * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
     *
     * <pre>
     * The quantity in bytes that the Groningen event log may grow before being
     * rotated.
     * </pre>
     */
    boolean hasEventLogRotateSizeBytes();
    /**
     * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
     *
     * <pre>
     * The quantity in bytes that the Groningen event log may grow before being
     * rotated.
     * </pre>
     */
    int getEventLogRotateSizeBytes();

    // optional int32 event_log_flush_interval_secs = 35 [default = 60];
    /**
     * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
     *
     * <pre>
     * The number of seconds that may transpire between Groningen event log
     * flushing.
     * </pre>
     */
    boolean hasEventLogFlushIntervalSecs();
    /**
     * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
     *
     * <pre>
     * The number of seconds that may transpire between Groningen event log
     * flushing.
     * </pre>
     */
    int getEventLogFlushIntervalSecs();

    // optional string additional_exec_paths = 36 [default = ""];
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    boolean hasAdditionalExecPaths();
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    java.lang.String getAdditionalExecPaths();
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    com.google.protobuf.ByteString
        getAdditionalExecPathsBytes();

    // optional string requested_pipeline_id = 37;
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    boolean hasRequestedPipelineId();
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    java.lang.String getRequestedPipelineId();
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    com.google.protobuf.ByteString
        getRequestedPipelineIdBytes();
  }
  /**
   * Protobuf type {@code org.arbeitspferde.groningen.proto.GroningenParams}
   */
  public static final class GroningenParams extends
      com.google.protobuf.GeneratedMessage
      implements GroningenParamsOrBuilder {
    // Use GroningenParams.newBuilder() to construct.
    private GroningenParams(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private GroningenParams(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final GroningenParams defaultInstance;
    public static GroningenParams getDefaultInstance() {
      return defaultInstance;
    }

    public GroningenParams getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private GroningenParams(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              bitField0_ |= 0x00000001;
              inputLogName_ = input.readBytes();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              duration_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              restart_ = input.readInt32();
              break;
            }
            case 41: {
              bitField0_ |= 0x00000008;
              latencyWeight_ = input.readDouble();
              break;
            }
            case 49: {
              bitField0_ |= 0x00000010;
              throughputWeight_ = input.readDouble();
              break;
            }
            case 65: {
              bitField0_ |= 0x00000020;
              memoryWeight_ = input.readDouble();
              break;
            }
            case 72: {
              bitField0_ |= 0x00000040;
              numCrossovers_ = input.readInt32();
              break;
            }
            case 81: {
              bitField0_ |= 0x00000080;
              mutationProb_ = input.readDouble();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000100;
              stagnantGens_ = input.readInt32();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000200;
              eliteCount_ = input.readInt32();
              break;
            }
            case 105: {
              bitField0_ |= 0x00000400;
              pauseTimeLatencyScorePercentile_ = input.readDouble();
              break;
            }
            case 112: {
              bitField0_ |= 0x00000800;
              numberOfExecutorThreads_ = input.readInt32();
              break;
            }
            case 120: {
              int rawValue = input.readEnum();
              org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode value = org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(15, rawValue);
              } else {
                bitField0_ |= 0x00001000;
                pipelineSyncType_ = value;
              }
              break;
            }
            case 128: {
              bitField0_ |= 0x00002000;
              healthCheckTimeout_ = input.readInt32();
              break;
            }
            case 136: {
              bitField0_ |= 0x00004000;
              healthCheckPollInterval_ = input.readInt32();
              break;
            }
            case 146: {
              bitField0_ |= 0x00008000;
              healthCheckServerType_ = input.readBytes();
              break;
            }
            case 152: {
              bitField0_ |= 0x00010000;
              metricQueryDeadlineSecs_ = input.readInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00020000;
              metricQueryChannelShutdownDelaySecs_ = input.readInt32();
              break;
            }
            case 168: {
              bitField0_ |= 0x00040000;
              metricQueryRetryMaximumCount_ = input.readInt32();
              break;
            }
            case 176: {
              bitField0_ |= 0x00080000;
              metricQueryRetryDelaySecs_ = input.readInt32();
              break;
            }
            case 184: {
              bitField0_ |= 0x00100000;
              executorWaitForOneSubjectRestartMs_ = input.readInt32();
              break;
            }
            case 192: {
              bitField0_ |= 0x00200000;
              executorSleepBtwnPollingMetricsMs_ = input.readInt32();
              break;
            }
            case 200: {
              bitField0_ |= 0x00400000;
              extractorNumberOfExtractorThreads_ = input.readInt32();
              break;
            }
            case 208: {
              bitField0_ |= 0x00800000;
              maximumInflightSubjectRestartCount_ = input.readInt32();
              break;
            }
            case 216: {
              bitField0_ |= 0x01000000;
              subjectManipulationDeadlineMs_ = input.readInt32();
              break;
            }
            case 226: {
              bitField0_ |= 0x02000000;
              checkpointFile_ = input.readBytes();
              break;
            }
            case 232: {
              bitField0_ |= 0x04000000;
              defaultInMemoryCacheTtl_ = input.readInt32();
              break;
            }
            case 240: {
              bitField0_ |= 0x08000000;
              maxSubjectsInFlightFraction_ = input.readInt32();
              break;
            }
            case 248: {
              bitField0_ |= 0x10000000;
              subjectGroupNumberOfShuffles_ = input.readInt32();
              break;
            }
            case 256: {
              bitField0_ |= 0x20000000;
              subjectsToDisplay_ = input.readInt32();
              break;
            }
            case 266: {
              bitField0_ |= 0x40000000;
              eventLogPrefix_ = input.readBytes();
              break;
            }
            case 272: {
              bitField0_ |= 0x80000000;
              eventLogRotateSizeBytes_ = input.readInt32();
              break;
            }
            case 280: {
              bitField1_ |= 0x00000001;
              eventLogFlushIntervalSecs_ = input.readInt32();
              break;
            }
            case 290: {
              bitField1_ |= 0x00000002;
              additionalExecPaths_ = input.readBytes();
              break;
            }
            case 298: {
              bitField1_ |= 0x00000004;
              requestedPipelineId_ = input.readBytes();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.arbeitspferde.groningen.proto.Params.internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.arbeitspferde.groningen.proto.Params.internal_static_org_arbeitspferde_groningen_proto_GroningenParams_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.arbeitspferde.groningen.proto.Params.GroningenParams.class, org.arbeitspferde.groningen.proto.Params.GroningenParams.Builder.class);
    }

    public static com.google.protobuf.Parser<GroningenParams> PARSER =
        new com.google.protobuf.AbstractParser<GroningenParams>() {
      public GroningenParams parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GroningenParams(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<GroningenParams> getParserForType() {
      return PARSER;
    }

    /**
     * Protobuf enum {@code org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode}
     *
     * <pre>
     * Groningen can run with various amounts of interaction between pipeline steps
     * This value is only read on creation of the pipeline (and not updated
     * between iterations
     * </pre>
     */
    public enum PipelineSynchMode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NONE = 0;</code>
       *
       * <pre>
       * No synchronization is performed. Groningen will run the subjects for the
       * duration specified in param_block, and on completion of an iteration of
       * the pipeline, will immediately go into another iteration
       * </pre>
       */
      NONE(0, 0),
      /**
       * <code>BASIC_SEMAPHORE = 1;</code>
       *
       * <pre>
       * Provides two points of synchronization:
       * - A point at the beginning of an iteration through the pipeline,
       *   Groningen waits before the Hypothesizer is run and blocks the rpc
       *   until the experimental settings have been generated and the subjects
       *   have been restarted in order to incorporate the experimental settings
       * - Another point that signals the experiment's duration is complete and
       *   blocks until all gc logs have been retrieved from remote systems,
       *   which would allow the experimental subjects to be downed. The duration
       *   setting above becomes a hard limit to prevent Groningen from waiting
       *   forever should the external agent crash or otherwise fail to signal
       *   the end of the experiment.
       * </pre>
       */
      BASIC_SEMAPHORE(1, 1),
      /**
       * <code>ITERATION_FINALIZATION_ONLY = 2;</code>
       *
       * <pre>
       * Provides a single point of synchronization at the end of an iteration at
       * which the pipeline will pause a flag is set allowing it to continue. The
       * flag can be set before the pipeline reaches the sync point.
       * </pre>
       */
      ITERATION_FINALIZATION_ONLY(2, 2),
      ;

      /**
       * <code>NONE = 0;</code>
       *
       * <pre>
       * No synchronization is performed. Groningen will run the subjects for the
       * duration specified in param_block, and on completion of an iteration of
       * the pipeline, will immediately go into another iteration
       * </pre>
       */
      public static final int NONE_VALUE = 0;
      /**
       * <code>BASIC_SEMAPHORE = 1;</code>
       *
       * <pre>
       * Provides two points of synchronization:
       * - A point at the beginning of an iteration through the pipeline,
       *   Groningen waits before the Hypothesizer is run and blocks the rpc
       *   until the experimental settings have been generated and the subjects
       *   have been restarted in order to incorporate the experimental settings
       * - Another point that signals the experiment's duration is complete and
       *   blocks until all gc logs have been retrieved from remote systems,
       *   which would allow the experimental subjects to be downed. The duration
       *   setting above becomes a hard limit to prevent Groningen from waiting
       *   forever should the external agent crash or otherwise fail to signal
       *   the end of the experiment.
       * </pre>
       */
      public static final int BASIC_SEMAPHORE_VALUE = 1;
      /**
       * <code>ITERATION_FINALIZATION_ONLY = 2;</code>
       *
       * <pre>
       * Provides a single point of synchronization at the end of an iteration at
       * which the pipeline will pause a flag is set allowing it to continue. The
       * flag can be set before the pipeline reaches the sync point.
       * </pre>
       */
      public static final int ITERATION_FINALIZATION_ONLY_VALUE = 2;


      public final int getNumber() { return value; }

      public static PipelineSynchMode valueOf(int value) {
        switch (value) {
          case 0: return NONE;
          case 1: return BASIC_SEMAPHORE;
          case 2: return ITERATION_FINALIZATION_ONLY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PipelineSynchMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<PipelineSynchMode>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PipelineSynchMode>() {
              public PipelineSynchMode findValueByNumber(int number) {
                return PipelineSynchMode.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.arbeitspferde.groningen.proto.Params.GroningenParams.getDescriptor().getEnumTypes().get(0);
      }

      private static final PipelineSynchMode[] VALUES = values();

      public static PipelineSynchMode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private PipelineSynchMode(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode)
    }

    private int bitField0_;
    private int bitField1_;
    // optional string input_log_name = 1;
    public static final int INPUT_LOG_NAME_FIELD_NUMBER = 1;
    private java.lang.Object inputLogName_;
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    public boolean hasInputLogName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    public java.lang.String getInputLogName() {
      java.lang.Object ref = inputLogName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          inputLogName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string input_log_name = 1;</code>
     *
     * <pre>
     * The basename of the subjects log file that Groningen will parse as input
     * </pre>
     */
    public com.google.protobuf.ByteString
        getInputLogNameBytes() {
      java.lang.Object ref = inputLogName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        inputLogName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional int32 duration = 2 [default = 1440];
    public static final int DURATION_FIELD_NUMBER = 2;
    private int duration_;
    /**
     * <code>optional int32 duration = 2 [default = 1440];</code>
     *
     * <pre>
     * time in minutes that the experiments run in production
     * </pre>
     */
    public boolean hasDuration() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional int32 duration = 2 [default = 1440];</code>
     *
     * <pre>
     * time in minutes that the experiments run in production
     * </pre>
     */
    public int getDuration() {
      return duration_;
    }

    // optional int32 restart = 3 [default = 4];
    public static final int RESTART_FIELD_NUMBER = 3;
    private int restart_;
    /**
     * <code>optional int32 restart = 3 [default = 4];</code>
     *
     * <pre>
     * experimental subject restart threshold used by the Executor and Validator
     * </pre>
     */
    public boolean hasRestart() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional int32 restart = 3 [default = 4];</code>
     *
     * <pre>
     * experimental subject restart threshold used by the Executor and Validator
     * </pre>
     */
    public int getRestart() {
      return restart_;
    }

    // optional double latency_weight = 5 [default = 1];
    public static final int LATENCY_WEIGHT_FIELD_NUMBER = 5;
    private double latencyWeight_;
    /**
     * <code>optional double latency_weight = 5 [default = 1];</code>
     *
     * <pre>
     * Weight of the latency score within the hypothesizer
     * </pre>
     */
    public boolean hasLatencyWeight() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional double latency_weight = 5 [default = 1];</code>
     *
     * <pre>
     * Weight of the latency score within the hypothesizer
     * </pre>
     */
    public double getLatencyWeight() {
      return latencyWeight_;
    }

    // optional double throughput_weight = 6 [default = 1];
    public static final int THROUGHPUT_WEIGHT_FIELD_NUMBER = 6;
    private double throughputWeight_;
    /**
     * <code>optional double throughput_weight = 6 [default = 1];</code>
     *
     * <pre>
     * Weight of the throughput score within the hypothesizer
     * </pre>
     */
    public boolean hasThroughputWeight() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional double throughput_weight = 6 [default = 1];</code>
     *
     * <pre>
     * Weight of the throughput score within the hypothesizer
     * </pre>
     */
    public double getThroughputWeight() {
      return throughputWeight_;
    }

    // optional double memory_weight = 8 [default = 1];
    public static final int MEMORY_WEIGHT_FIELD_NUMBER = 8;
    private double memoryWeight_;
    /**
     * <code>optional double memory_weight = 8 [default = 1];</code>
     *
     * <pre>
     * Weight of the memory score within the hypothesizer
     * </pre>
     */
    public boolean hasMemoryWeight() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional double memory_weight = 8 [default = 1];</code>
     *
     * <pre>
     * Weight of the memory score within the hypothesizer
     * </pre>
     */
    public double getMemoryWeight() {
      return memoryWeight_;
    }

    // optional int32 num_crossovers = 9 [default = 1];
    public static final int NUM_CROSSOVERS_FIELD_NUMBER = 9;
    private int numCrossovers_;
    /**
     * <code>optional int32 num_crossovers = 9 [default = 1];</code>
     *
     * <pre>
     * Number cross-over points for mating within hypothesizer
     * </pre>
     */
    public boolean hasNumCrossovers() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional int32 num_crossovers = 9 [default = 1];</code>
     *
     * <pre>
     * Number cross-over points for mating within hypothesizer
     * </pre>
     */
    public int getNumCrossovers() {
      return numCrossovers_;
    }

    // optional double mutation_prob = 10 [default = 0.02];
    public static final int MUTATION_PROB_FIELD_NUMBER = 10;
    private double mutationProb_;
    /**
     * <code>optional double mutation_prob = 10 [default = 0.02];</code>
     *
     * <pre>
     * Mutation probability for the offsprings
     * </pre>
     */
    public boolean hasMutationProb() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional double mutation_prob = 10 [default = 0.02];</code>
     *
     * <pre>
     * Mutation probability for the offsprings
     * </pre>
     */
    public double getMutationProb() {
      return mutationProb_;
    }

    // optional int32 stagnant_gens = 11 [default = 0];
    public static final int STAGNANT_GENS_FIELD_NUMBER = 11;
    private int stagnantGens_;
    /**
     * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
     *
     * <pre>
     * Number of stagnant generations before GA terminates. The value 0 disables
     * this termination condition check.
     * </pre>
     */
    public boolean hasStagnantGens() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
     *
     * <pre>
     * Number of stagnant generations before GA terminates. The value 0 disables
     * this termination condition check.
     * </pre>
     */
    public int getStagnantGens() {
      return stagnantGens_;
    }

    // optional int32 elite_count = 12 [default = 1];
    public static final int ELITE_COUNT_FIELD_NUMBER = 12;
    private int eliteCount_;
    /**
     * <code>optional int32 elite_count = 12 [default = 1];</code>
     *
     * <pre>
     * Number of elite individuals in the populations for the
     *  IncrementalEvolutionEngine
     * NOTE: is not updated after the initial pass through the loop.
     * </pre>
     */
    public boolean hasEliteCount() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional int32 elite_count = 12 [default = 1];</code>
     *
     * <pre>
     * Number of elite individuals in the populations for the
     *  IncrementalEvolutionEngine
     * NOTE: is not updated after the initial pass through the loop.
     * </pre>
     */
    public int getEliteCount() {
      return eliteCount_;
    }

    // optional double pause_time_latency_score_percentile = 13 [default = 99];
    public static final int PAUSE_TIME_LATENCY_SCORE_PERCENTILE_FIELD_NUMBER = 13;
    private double pauseTimeLatencyScorePercentile_;
    /**
     * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
     *
     * <pre>
     * The percentile used to compute the latency score (A value from 0 to 100)
     * </pre>
     */
    public boolean hasPauseTimeLatencyScorePercentile() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
     *
     * <pre>
     * The percentile used to compute the latency score (A value from 0 to 100)
     * </pre>
     */
    public double getPauseTimeLatencyScorePercentile() {
      return pauseTimeLatencyScorePercentile_;
    }

    // optional int32 number_of_executor_threads = 14 [default = 3];
    public static final int NUMBER_OF_EXECUTOR_THREADS_FIELD_NUMBER = 14;
    private int numberOfExecutorThreads_;
    /**
     * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
     *
     * <pre>
     * The number of threads that the Executor uses to monitor experimental
     * subjects.  Quite likely, you'll want to increase this as you increase the
     * total number of subjects in your experiment. Less threads probably implies
     * alonger period of time between sucessive probes of a given experimental
     * subject.
     * </pre>
     */
    public boolean hasNumberOfExecutorThreads() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
     *
     * <pre>
     * The number of threads that the Executor uses to monitor experimental
     * subjects.  Quite likely, you'll want to increase this as you increase the
     * total number of subjects in your experiment. Less threads probably implies
     * alonger period of time between sucessive probes of a given experimental
     * subject.
     * </pre>
     */
    public int getNumberOfExecutorThreads() {
      return numberOfExecutorThreads_;
    }

    // optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];
    public static final int PIPELINE_SYNC_TYPE_FIELD_NUMBER = 15;
    private org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode pipelineSyncType_;
    /**
     * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
     */
    public boolean hasPipelineSyncType() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
     */
    public org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode getPipelineSyncType() {
      return pipelineSyncType_;
    }

    // optional int32 health_check_timeout = 16 [default = 30000];
    public static final int HEALTH_CHECK_TIMEOUT_FIELD_NUMBER = 16;
    private int healthCheckTimeout_;
    /**
     * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
     *
     * <pre>
     * How long we wait for a health check check
     * </pre>
     */
    public boolean hasHealthCheckTimeout() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
     *
     * <pre>
     * How long we wait for a health check check
     * </pre>
     */
    public int getHealthCheckTimeout() {
      return healthCheckTimeout_;
    }

    // optional int32 health_check_poll_interval = 17 [default = 5000];
    public static final int HEALTH_CHECK_POLL_INTERVAL_FIELD_NUMBER = 17;
    private int healthCheckPollInterval_;
    /**
     * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
     *
     * <pre>
     * How long we sleep between health checks.
     * </pre>
     */
    public boolean hasHealthCheckPollInterval() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
     *
     * <pre>
     * How long we sleep between health checks.
     * </pre>
     */
    public int getHealthCheckPollInterval() {
      return healthCheckPollInterval_;
    }

    // optional string health_check_server_type = 18 [default = ""];
    public static final int HEALTH_CHECK_SERVER_TYPE_FIELD_NUMBER = 18;
    private java.lang.Object healthCheckServerType_;
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    public boolean hasHealthCheckServerType() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    public java.lang.String getHealthCheckServerType() {
      java.lang.Object ref = healthCheckServerType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          healthCheckServerType_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string health_check_server_type = 18 [default = ""];</code>
     *
     * <pre>
     * The type of server that is supposed to be registered at the recipient end.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getHealthCheckServerTypeBytes() {
      java.lang.Object ref = healthCheckServerType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        healthCheckServerType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional int32 metric_query_deadline_secs = 19 [default = 3];
    public static final int METRIC_QUERY_DEADLINE_SECS_FIELD_NUMBER = 19;
    private int metricQueryDeadlineSecs_;
    /**
     * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
     *
     * <pre>
     * The default deadline in seconds for metric queries.
     * </pre>
     */
    public boolean hasMetricQueryDeadlineSecs() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
     *
     * <pre>
     * The default deadline in seconds for metric queries.
     * </pre>
     */
    public int getMetricQueryDeadlineSecs() {
      return metricQueryDeadlineSecs_;
    }

    // optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];
    public static final int METRIC_QUERY_CHANNEL_SHUTDOWN_DELAY_SECS_FIELD_NUMBER = 20;
    private int metricQueryChannelShutdownDelaySecs_;
    /**
     * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
     *
     * <pre>
     * The default channel TTL in seconds for metric query channel.
     * </pre>
     */
    public boolean hasMetricQueryChannelShutdownDelaySecs() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
     *
     * <pre>
     * The default channel TTL in seconds for metric query channel.
     * </pre>
     */
    public int getMetricQueryChannelShutdownDelaySecs() {
      return metricQueryChannelShutdownDelaySecs_;
    }

    // optional int32 metric_query_retry_maximum_count = 21 [default = 3];
    public static final int METRIC_QUERY_RETRY_MAXIMUM_COUNT_FIELD_NUMBER = 21;
    private int metricQueryRetryMaximumCount_;
    /**
     * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
     *
     * <pre>
     * The maximum number of times the metric query pipeline will attempt to query.
     * </pre>
     */
    public boolean hasMetricQueryRetryMaximumCount() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
     *
     * <pre>
     * The maximum number of times the metric query pipeline will attempt to query.
     * </pre>
     */
    public int getMetricQueryRetryMaximumCount() {
      return metricQueryRetryMaximumCount_;
    }

    // optional int32 metric_query_retry_delay_secs = 22 [default = 2];
    public static final int METRIC_QUERY_RETRY_DELAY_SECS_FIELD_NUMBER = 22;
    private int metricQueryRetryDelaySecs_;
    /**
     * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
     *
     * <pre>
     * The initial delay in seconds between retries for metric query failures.
     * </pre>
     */
    public boolean hasMetricQueryRetryDelaySecs() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
     *
     * <pre>
     * The initial delay in seconds between retries for metric query failures.
     * </pre>
     */
    public int getMetricQueryRetryDelaySecs() {
      return metricQueryRetryDelaySecs_;
    }

    // optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];
    public static final int EXECUTOR_WAIT_FOR_ONE_SUBJECT_RESTART_MS_FIELD_NUMBER = 23;
    private int executorWaitForOneSubjectRestartMs_;
    /**
     * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
     *
     * <pre>
     * Deadline (ms) of how long to wait for a subject to restart.
     * </pre>
     */
    public boolean hasExecutorWaitForOneSubjectRestartMs() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
     *
     * <pre>
     * Deadline (ms) of how long to wait for a subject to restart.
     * </pre>
     */
    public int getExecutorWaitForOneSubjectRestartMs() {
      return executorWaitForOneSubjectRestartMs_;
    }

    // optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];
    public static final int EXECUTOR_SLEEP_BTWN_POLLING_METRICS_MS_FIELD_NUMBER = 24;
    private int executorSleepBtwnPollingMetricsMs_;
    /**
     * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
     *
     * <pre>
     * Interval (ms) we wait between an iteration of polling subjects
     * </pre>
     */
    public boolean hasExecutorSleepBtwnPollingMetricsMs() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
     *
     * <pre>
     * Interval (ms) we wait between an iteration of polling subjects
     * </pre>
     */
    public int getExecutorSleepBtwnPollingMetricsMs() {
      return executorSleepBtwnPollingMetricsMs_;
    }

    // optional int32 extractor_number_of_extractor_threads = 25 [default = 10];
    public static final int EXTRACTOR_NUMBER_OF_EXTRACTOR_THREADS_FIELD_NUMBER = 25;
    private int extractorNumberOfExtractorThreads_;
    /**
     * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
     *
     * <pre>
     * The number of extractor threads.
     * </pre>
     */
    public boolean hasExtractorNumberOfExtractorThreads() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
     *
     * <pre>
     * The number of extractor threads.
     * </pre>
     */
    public int getExtractorNumberOfExtractorThreads() {
      return extractorNumberOfExtractorThreads_;
    }

    // optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];
    public static final int MAXIMUM_INFLIGHT_SUBJECT_RESTART_COUNT_FIELD_NUMBER = 26;
    private int maximumInflightSubjectRestartCount_;
    /**
     * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
     *
     * <pre>
     * Maximum number of subjects to restart at once.
     * </pre>
     */
    public boolean hasMaximumInflightSubjectRestartCount() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
     *
     * <pre>
     * Maximum number of subjects to restart at once.
     * </pre>
     */
    public int getMaximumInflightSubjectRestartCount() {
      return maximumInflightSubjectRestartCount_;
    }

    // optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];
    public static final int SUBJECT_MANIPULATION_DEADLINE_MS_FIELD_NUMBER = 27;
    private int subjectManipulationDeadlineMs_;
    /**
     * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
     *
     * <pre>
     * The deadline (ms) for subject manipulation to occur.
     * </pre>
     */
    public boolean hasSubjectManipulationDeadlineMs() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
     *
     * <pre>
     * The deadline (ms) for subject manipulation to occur.
     * </pre>
     */
    public int getSubjectManipulationDeadlineMs() {
      return subjectManipulationDeadlineMs_;
    }

    // optional string checkpoint_file = 28 [default = ""];
    public static final int CHECKPOINT_FILE_FIELD_NUMBER = 28;
    private java.lang.Object checkpointFile_;
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    public boolean hasCheckpointFile() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    public java.lang.String getCheckpointFile() {
      java.lang.Object ref = checkpointFile_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          checkpointFile_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string checkpoint_file = 28 [default = ""];</code>
     *
     * <pre>
     * File that contains the last experiment.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getCheckpointFileBytes() {
      java.lang.Object ref = checkpointFile_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        checkpointFile_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional int32 default_in_memory_cache_ttl = 29 [default = 600000];
    public static final int DEFAULT_IN_MEMORY_CACHE_TTL_FIELD_NUMBER = 29;
    private int defaultInMemoryCacheTtl_;
    /**
     * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
     *
     * <pre>
     * The maximum TTL in seconds for objects in the memory-sensitive caches.
     * </pre>
     */
    public boolean hasDefaultInMemoryCacheTtl() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
     *
     * <pre>
     * The maximum TTL in seconds for objects in the memory-sensitive caches.
     * </pre>
     */
    public int getDefaultInMemoryCacheTtl() {
      return defaultInMemoryCacheTtl_;
    }

    // optional int32 max_subjects_in_flight_fraction = 30 [default = 3];
    public static final int MAX_SUBJECTS_IN_FLIGHT_FRACTION_FIELD_NUMBER = 30;
    private int maxSubjectsInFlightFraction_;
    /**
     * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
     *
     * <pre>
     * Divisor for max subjects in-flight for rolling subject group restart.
     * (maxInFlight = # subjects / this divisor)
     * </pre>
     */
    public boolean hasMaxSubjectsInFlightFraction() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
     *
     * <pre>
     * Divisor for max subjects in-flight for rolling subject group restart.
     * (maxInFlight = # subjects / this divisor)
     * </pre>
     */
    public int getMaxSubjectsInFlightFraction() {
      return maxSubjectsInFlightFraction_;
    }

    // optional int32 subject_group_number_of_shuffles = 31 [default = 8];
    public static final int SUBJECT_GROUP_NUMBER_OF_SHUFFLES_FIELD_NUMBER = 31;
    private int subjectGroupNumberOfShuffles_;
    /**
     * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
     *
     * <pre>
     * The number of times to shuffle the subjects.
     * </pre>
     */
    public boolean hasSubjectGroupNumberOfShuffles() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
     *
     * <pre>
     * The number of times to shuffle the subjects.
     * </pre>
     */
    public int getSubjectGroupNumberOfShuffles() {
      return subjectGroupNumberOfShuffles_;
    }

    // optional int32 subjects_to_display = 32 [default = 5];
    public static final int SUBJECTS_TO_DISPLAY_FIELD_NUMBER = 32;
    private int subjectsToDisplay_;
    /**
     * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
     *
     * <pre>
     * The number of subjects to display in Groningen's HUD.
     * </pre>
     */
    public boolean hasSubjectsToDisplay() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
     *
     * <pre>
     * The number of subjects to display in Groningen's HUD.
     * </pre>
     */
    public int getSubjectsToDisplay() {
      return subjectsToDisplay_;
    }

    // optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];
    public static final int EVENT_LOG_PREFIX_FIELD_NUMBER = 33;
    private java.lang.Object eventLogPrefix_;
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    public boolean hasEventLogPrefix() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    public java.lang.String getEventLogPrefix() {
      java.lang.Object ref = eventLogPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          eventLogPrefix_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
     *
     * <pre>
     * The path along with base string prefix for the Groningen event log.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getEventLogPrefixBytes() {
      java.lang.Object ref = eventLogPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        eventLogPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];
    public static final int EVENT_LOG_ROTATE_SIZE_BYTES_FIELD_NUMBER = 34;
    private int eventLogRotateSizeBytes_;
    /**
     * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
     *
     * <pre>
     * The quantity in bytes that the Groningen event log may grow before being
     * rotated.
     * </pre>
     */
    public boolean hasEventLogRotateSizeBytes() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
     *
     * <pre>
     * The quantity in bytes that the Groningen event log may grow before being
     * rotated.
     * </pre>
     */
    public int getEventLogRotateSizeBytes() {
      return eventLogRotateSizeBytes_;
    }

    // optional int32 event_log_flush_interval_secs = 35 [default = 60];
    public static final int EVENT_LOG_FLUSH_INTERVAL_SECS_FIELD_NUMBER = 35;
    private int eventLogFlushIntervalSecs_;
    /**
     * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
     *
     * <pre>
     * The number of seconds that may transpire between Groningen event log
     * flushing.
     * </pre>
     */
    public boolean hasEventLogFlushIntervalSecs() {
      return ((bitField1_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
     *
     * <pre>
     * The number of seconds that may transpire between Groningen event log
     * flushing.
     * </pre>
     */
    public int getEventLogFlushIntervalSecs() {
      return eventLogFlushIntervalSecs_;
    }

    // optional string additional_exec_paths = 36 [default = ""];
    public static final int ADDITIONAL_EXEC_PATHS_FIELD_NUMBER = 36;
    private java.lang.Object additionalExecPaths_;
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    public boolean hasAdditionalExecPaths() {
      return ((bitField1_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    public java.lang.String getAdditionalExecPaths() {
      java.lang.Object ref = additionalExecPaths_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          additionalExecPaths_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string additional_exec_paths = 36 [default = ""];</code>
     *
     * <pre>
     * Additional paths where executable permissions will be set when running
     * experiments.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getAdditionalExecPathsBytes() {
      java.lang.Object ref = additionalExecPaths_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        additionalExecPaths_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional string requested_pipeline_id = 37;
    public static final int REQUESTED_PIPELINE_ID_FIELD_NUMBER = 37;
    private java.lang.Object requestedPipelineId_;
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    public boolean hasRequestedPipelineId() {
      return ((bitField1_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    public java.lang.String getRequestedPipelineId() {
      java.lang.Object ref = requestedPipelineId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          requestedPipelineId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string requested_pipeline_id = 37;</code>
     *
     * <pre>
     * Request specific pipeline ID, otherwise it will be auto generated.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getRequestedPipelineIdBytes() {
      java.lang.Object ref = requestedPipelineId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        requestedPipelineId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private void initFields() {
      inputLogName_ = "";
      duration_ = 1440;
      restart_ = 4;
      latencyWeight_ = 1D;
      throughputWeight_ = 1D;
      memoryWeight_ = 1D;
      numCrossovers_ = 1;
      mutationProb_ = 0.02D;
      stagnantGens_ = 0;
      eliteCount_ = 1;
      pauseTimeLatencyScorePercentile_ = 99D;
      numberOfExecutorThreads_ = 3;
      pipelineSyncType_ = org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode.NONE;
      healthCheckTimeout_ = 30000;
      healthCheckPollInterval_ = 5000;
      healthCheckServerType_ = "";
      metricQueryDeadlineSecs_ = 3;
      metricQueryChannelShutdownDelaySecs_ = 3;
      metricQueryRetryMaximumCount_ = 3;
      metricQueryRetryDelaySecs_ = 2;
      executorWaitForOneSubjectRestartMs_ = 30000;
      executorSleepBtwnPollingMetricsMs_ = 60000;
      extractorNumberOfExtractorThreads_ = 10;
      maximumInflightSubjectRestartCount_ = 1;
      subjectManipulationDeadlineMs_ = 30000;
      checkpointFile_ = "";
      defaultInMemoryCacheTtl_ = 600000;
      maxSubjectsInFlightFraction_ = 3;
      subjectGroupNumberOfShuffles_ = 8;
      subjectsToDisplay_ = 5;
      eventLogPrefix_ = "alloc/logs/tmp-groningen_events";
      eventLogRotateSizeBytes_ = 524288000;
      eventLogFlushIntervalSecs_ = 60;
      additionalExecPaths_ = "";
      requestedPipelineId_ = "";
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized != -1) return isInitialized == 1;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getInputLogNameBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, duration_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, restart_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeDouble(5, latencyWeight_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeDouble(6, throughputWeight_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeDouble(8, memoryWeight_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(9, numCrossovers_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeDouble(10, mutationProb_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(11, stagnantGens_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt32(12, eliteCount_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeDouble(13, pauseTimeLatencyScorePercentile_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeInt32(14, numberOfExecutorThreads_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeEnum(15, pipelineSyncType_.getNumber());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeInt32(16, healthCheckTimeout_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeInt32(17, healthCheckPollInterval_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeBytes(18, getHealthCheckServerTypeBytes());
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(19, metricQueryDeadlineSecs_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(20, metricQueryChannelShutdownDelaySecs_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(21, metricQueryRetryMaximumCount_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeInt32(22, metricQueryRetryDelaySecs_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeInt32(23, executorWaitForOneSubjectRestartMs_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeInt32(24, executorSleepBtwnPollingMetricsMs_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeInt32(25, extractorNumberOfExtractorThreads_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeInt32(26, maximumInflightSubjectRestartCount_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeInt32(27, subjectManipulationDeadlineMs_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeBytes(28, getCheckpointFileBytes());
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeInt32(29, defaultInMemoryCacheTtl_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeInt32(30, maxSubjectsInFlightFraction_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeInt32(31, subjectGroupNumberOfShuffles_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeInt32(32, subjectsToDisplay_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeBytes(33, getEventLogPrefixBytes());
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeInt32(34, eventLogRotateSizeBytes_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(35, eventLogFlushIntervalSecs_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(36, getAdditionalExecPathsBytes());
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(37, getRequestedPipelineIdBytes());
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, getInputLogNameBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, duration_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, restart_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(5, latencyWeight_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(6, throughputWeight_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(8, memoryWeight_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, numCrossovers_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(10, mutationProb_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, stagnantGens_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(12, eliteCount_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(13, pauseTimeLatencyScorePercentile_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(14, numberOfExecutorThreads_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(15, pipelineSyncType_.getNumber());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(16, healthCheckTimeout_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(17, healthCheckPollInterval_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(18, getHealthCheckServerTypeBytes());
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(19, metricQueryDeadlineSecs_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, metricQueryChannelShutdownDelaySecs_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(21, metricQueryRetryMaximumCount_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(22, metricQueryRetryDelaySecs_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(23, executorWaitForOneSubjectRestartMs_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(24, executorSleepBtwnPollingMetricsMs_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(25, extractorNumberOfExtractorThreads_);
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(26, maximumInflightSubjectRestartCount_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(27, subjectManipulationDeadlineMs_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(28, getCheckpointFileBytes());
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(29, defaultInMemoryCacheTtl_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(30, maxSubjectsInFlightFraction_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(31, subjectGroupNumberOfShuffles_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(32, subjectsToDisplay_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(33, getEventLogPrefixBytes());
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(34, eventLogRotateSizeBytes_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(35, eventLogFlushIntervalSecs_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(36, getAdditionalExecPathsBytes());
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(37, getRequestedPipelineIdBytes());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.arbeitspferde.groningen.proto.Params.GroningenParams parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(org.arbeitspferde.groningen.proto.Params.GroningenParams prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code org.arbeitspferde.groningen.proto.GroningenParams}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder>
       implements org.arbeitspferde.groningen.proto.Params.GroningenParamsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.arbeitspferde.groningen.proto.Params.internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.arbeitspferde.groningen.proto.Params.internal_static_org_arbeitspferde_groningen_proto_GroningenParams_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.arbeitspferde.groningen.proto.Params.GroningenParams.class, org.arbeitspferde.groningen.proto.Params.GroningenParams.Builder.class);
      }

      // Construct using org.arbeitspferde.groningen.proto.Params.GroningenParams.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        inputLogName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        duration_ = 1440;
        bitField0_ = (bitField0_ & ~0x00000002);
        restart_ = 4;
        bitField0_ = (bitField0_ & ~0x00000004);
        latencyWeight_ = 1D;
        bitField0_ = (bitField0_ & ~0x00000008);
        throughputWeight_ = 1D;
        bitField0_ = (bitField0_ & ~0x00000010);
        memoryWeight_ = 1D;
        bitField0_ = (bitField0_ & ~0x00000020);
        numCrossovers_ = 1;
        bitField0_ = (bitField0_ & ~0x00000040);
        mutationProb_ = 0.02D;
        bitField0_ = (bitField0_ & ~0x00000080);
        stagnantGens_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        eliteCount_ = 1;
        bitField0_ = (bitField0_ & ~0x00000200);
        pauseTimeLatencyScorePercentile_ = 99D;
        bitField0_ = (bitField0_ & ~0x00000400);
        numberOfExecutorThreads_ = 3;
        bitField0_ = (bitField0_ & ~0x00000800);
        pipelineSyncType_ = org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode.NONE;
        bitField0_ = (bitField0_ & ~0x00001000);
        healthCheckTimeout_ = 30000;
        bitField0_ = (bitField0_ & ~0x00002000);
        healthCheckPollInterval_ = 5000;
        bitField0_ = (bitField0_ & ~0x00004000);
        healthCheckServerType_ = "";
        bitField0_ = (bitField0_ & ~0x00008000);
        metricQueryDeadlineSecs_ = 3;
        bitField0_ = (bitField0_ & ~0x00010000);
        metricQueryChannelShutdownDelaySecs_ = 3;
        bitField0_ = (bitField0_ & ~0x00020000);
        metricQueryRetryMaximumCount_ = 3;
        bitField0_ = (bitField0_ & ~0x00040000);
        metricQueryRetryDelaySecs_ = 2;
        bitField0_ = (bitField0_ & ~0x00080000);
        executorWaitForOneSubjectRestartMs_ = 30000;
        bitField0_ = (bitField0_ & ~0x00100000);
        executorSleepBtwnPollingMetricsMs_ = 60000;
        bitField0_ = (bitField0_ & ~0x00200000);
        extractorNumberOfExtractorThreads_ = 10;
        bitField0_ = (bitField0_ & ~0x00400000);
        maximumInflightSubjectRestartCount_ = 1;
        bitField0_ = (bitField0_ & ~0x00800000);
        subjectManipulationDeadlineMs_ = 30000;
        bitField0_ = (bitField0_ & ~0x01000000);
        checkpointFile_ = "";
        bitField0_ = (bitField0_ & ~0x02000000);
        defaultInMemoryCacheTtl_ = 600000;
        bitField0_ = (bitField0_ & ~0x04000000);
        maxSubjectsInFlightFraction_ = 3;
        bitField0_ = (bitField0_ & ~0x08000000);
        subjectGroupNumberOfShuffles_ = 8;
        bitField0_ = (bitField0_ & ~0x10000000);
        subjectsToDisplay_ = 5;
        bitField0_ = (bitField0_ & ~0x20000000);
        eventLogPrefix_ = "alloc/logs/tmp-groningen_events";
        bitField0_ = (bitField0_ & ~0x40000000);
        eventLogRotateSizeBytes_ = 524288000;
        bitField0_ = (bitField0_ & ~0x80000000);
        eventLogFlushIntervalSecs_ = 60;
        bitField1_ = (bitField1_ & ~0x00000001);
        additionalExecPaths_ = "";
        bitField1_ = (bitField1_ & ~0x00000002);
        requestedPipelineId_ = "";
        bitField1_ = (bitField1_ & ~0x00000004);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.arbeitspferde.groningen.proto.Params.internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor;
      }

      public org.arbeitspferde.groningen.proto.Params.GroningenParams getDefaultInstanceForType() {
        return org.arbeitspferde.groningen.proto.Params.GroningenParams.getDefaultInstance();
      }

      public org.arbeitspferde.groningen.proto.Params.GroningenParams build() {
        org.arbeitspferde.groningen.proto.Params.GroningenParams result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.arbeitspferde.groningen.proto.Params.GroningenParams buildPartial() {
        org.arbeitspferde.groningen.proto.Params.GroningenParams result = new org.arbeitspferde.groningen.proto.Params.GroningenParams(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.inputLogName_ = inputLogName_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.duration_ = duration_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.restart_ = restart_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.latencyWeight_ = latencyWeight_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.throughputWeight_ = throughputWeight_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.memoryWeight_ = memoryWeight_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.numCrossovers_ = numCrossovers_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.mutationProb_ = mutationProb_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.stagnantGens_ = stagnantGens_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.eliteCount_ = eliteCount_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.pauseTimeLatencyScorePercentile_ = pauseTimeLatencyScorePercentile_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.numberOfExecutorThreads_ = numberOfExecutorThreads_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.pipelineSyncType_ = pipelineSyncType_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.healthCheckTimeout_ = healthCheckTimeout_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.healthCheckPollInterval_ = healthCheckPollInterval_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.healthCheckServerType_ = healthCheckServerType_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.metricQueryDeadlineSecs_ = metricQueryDeadlineSecs_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.metricQueryChannelShutdownDelaySecs_ = metricQueryChannelShutdownDelaySecs_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.metricQueryRetryMaximumCount_ = metricQueryRetryMaximumCount_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.metricQueryRetryDelaySecs_ = metricQueryRetryDelaySecs_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.executorWaitForOneSubjectRestartMs_ = executorWaitForOneSubjectRestartMs_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.executorSleepBtwnPollingMetricsMs_ = executorSleepBtwnPollingMetricsMs_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.extractorNumberOfExtractorThreads_ = extractorNumberOfExtractorThreads_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.maximumInflightSubjectRestartCount_ = maximumInflightSubjectRestartCount_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.subjectManipulationDeadlineMs_ = subjectManipulationDeadlineMs_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.checkpointFile_ = checkpointFile_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.defaultInMemoryCacheTtl_ = defaultInMemoryCacheTtl_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.maxSubjectsInFlightFraction_ = maxSubjectsInFlightFraction_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.subjectGroupNumberOfShuffles_ = subjectGroupNumberOfShuffles_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.subjectsToDisplay_ = subjectsToDisplay_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x40000000;
        }
        result.eventLogPrefix_ = eventLogPrefix_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x80000000;
        }
        result.eventLogRotateSizeBytes_ = eventLogRotateSizeBytes_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField1_ |= 0x00000001;
        }
        result.eventLogFlushIntervalSecs_ = eventLogFlushIntervalSecs_;
        if (((from_bitField1_ & 0x00000002) == 0x00000002)) {
          to_bitField1_ |= 0x00000002;
        }
        result.additionalExecPaths_ = additionalExecPaths_;
        if (((from_bitField1_ & 0x00000004) == 0x00000004)) {
          to_bitField1_ |= 0x00000004;
        }
        result.requestedPipelineId_ = requestedPipelineId_;
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.arbeitspferde.groningen.proto.Params.GroningenParams) {
          return mergeFrom((org.arbeitspferde.groningen.proto.Params.GroningenParams)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.arbeitspferde.groningen.proto.Params.GroningenParams other) {
        if (other == org.arbeitspferde.groningen.proto.Params.GroningenParams.getDefaultInstance()) return this;
        if (other.hasInputLogName()) {
          bitField0_ |= 0x00000001;
          inputLogName_ = other.inputLogName_;
          onChanged();
        }
        if (other.hasDuration()) {
          setDuration(other.getDuration());
        }
        if (other.hasRestart()) {
          setRestart(other.getRestart());
        }
        if (other.hasLatencyWeight()) {
          setLatencyWeight(other.getLatencyWeight());
        }
        if (other.hasThroughputWeight()) {
          setThroughputWeight(other.getThroughputWeight());
        }
        if (other.hasMemoryWeight()) {
          setMemoryWeight(other.getMemoryWeight());
        }
        if (other.hasNumCrossovers()) {
          setNumCrossovers(other.getNumCrossovers());
        }
        if (other.hasMutationProb()) {
          setMutationProb(other.getMutationProb());
        }
        if (other.hasStagnantGens()) {
          setStagnantGens(other.getStagnantGens());
        }
        if (other.hasEliteCount()) {
          setEliteCount(other.getEliteCount());
        }
        if (other.hasPauseTimeLatencyScorePercentile()) {
          setPauseTimeLatencyScorePercentile(other.getPauseTimeLatencyScorePercentile());
        }
        if (other.hasNumberOfExecutorThreads()) {
          setNumberOfExecutorThreads(other.getNumberOfExecutorThreads());
        }
        if (other.hasPipelineSyncType()) {
          setPipelineSyncType(other.getPipelineSyncType());
        }
        if (other.hasHealthCheckTimeout()) {
          setHealthCheckTimeout(other.getHealthCheckTimeout());
        }
        if (other.hasHealthCheckPollInterval()) {
          setHealthCheckPollInterval(other.getHealthCheckPollInterval());
        }
        if (other.hasHealthCheckServerType()) {
          bitField0_ |= 0x00008000;
          healthCheckServerType_ = other.healthCheckServerType_;
          onChanged();
        }
        if (other.hasMetricQueryDeadlineSecs()) {
          setMetricQueryDeadlineSecs(other.getMetricQueryDeadlineSecs());
        }
        if (other.hasMetricQueryChannelShutdownDelaySecs()) {
          setMetricQueryChannelShutdownDelaySecs(other.getMetricQueryChannelShutdownDelaySecs());
        }
        if (other.hasMetricQueryRetryMaximumCount()) {
          setMetricQueryRetryMaximumCount(other.getMetricQueryRetryMaximumCount());
        }
        if (other.hasMetricQueryRetryDelaySecs()) {
          setMetricQueryRetryDelaySecs(other.getMetricQueryRetryDelaySecs());
        }
        if (other.hasExecutorWaitForOneSubjectRestartMs()) {
          setExecutorWaitForOneSubjectRestartMs(other.getExecutorWaitForOneSubjectRestartMs());
        }
        if (other.hasExecutorSleepBtwnPollingMetricsMs()) {
          setExecutorSleepBtwnPollingMetricsMs(other.getExecutorSleepBtwnPollingMetricsMs());
        }
        if (other.hasExtractorNumberOfExtractorThreads()) {
          setExtractorNumberOfExtractorThreads(other.getExtractorNumberOfExtractorThreads());
        }
        if (other.hasMaximumInflightSubjectRestartCount()) {
          setMaximumInflightSubjectRestartCount(other.getMaximumInflightSubjectRestartCount());
        }
        if (other.hasSubjectManipulationDeadlineMs()) {
          setSubjectManipulationDeadlineMs(other.getSubjectManipulationDeadlineMs());
        }
        if (other.hasCheckpointFile()) {
          bitField0_ |= 0x02000000;
          checkpointFile_ = other.checkpointFile_;
          onChanged();
        }
        if (other.hasDefaultInMemoryCacheTtl()) {
          setDefaultInMemoryCacheTtl(other.getDefaultInMemoryCacheTtl());
        }
        if (other.hasMaxSubjectsInFlightFraction()) {
          setMaxSubjectsInFlightFraction(other.getMaxSubjectsInFlightFraction());
        }
        if (other.hasSubjectGroupNumberOfShuffles()) {
          setSubjectGroupNumberOfShuffles(other.getSubjectGroupNumberOfShuffles());
        }
        if (other.hasSubjectsToDisplay()) {
          setSubjectsToDisplay(other.getSubjectsToDisplay());
        }
        if (other.hasEventLogPrefix()) {
          bitField0_ |= 0x40000000;
          eventLogPrefix_ = other.eventLogPrefix_;
          onChanged();
        }
        if (other.hasEventLogRotateSizeBytes()) {
          setEventLogRotateSizeBytes(other.getEventLogRotateSizeBytes());
        }
        if (other.hasEventLogFlushIntervalSecs()) {
          setEventLogFlushIntervalSecs(other.getEventLogFlushIntervalSecs());
        }
        if (other.hasAdditionalExecPaths()) {
          bitField1_ |= 0x00000002;
          additionalExecPaths_ = other.additionalExecPaths_;
          onChanged();
        }
        if (other.hasRequestedPipelineId()) {
          bitField1_ |= 0x00000004;
          requestedPipelineId_ = other.requestedPipelineId_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.arbeitspferde.groningen.proto.Params.GroningenParams parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.arbeitspferde.groningen.proto.Params.GroningenParams) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      // optional string input_log_name = 1;
      private java.lang.Object inputLogName_ = "";
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public boolean hasInputLogName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public java.lang.String getInputLogName() {
        java.lang.Object ref = inputLogName_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          inputLogName_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public com.google.protobuf.ByteString
          getInputLogNameBytes() {
        java.lang.Object ref = inputLogName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          inputLogName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public Builder setInputLogName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        inputLogName_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public Builder clearInputLogName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        inputLogName_ = getDefaultInstance().getInputLogName();
        onChanged();
        return this;
      }
      /**
       * <code>optional string input_log_name = 1;</code>
       *
       * <pre>
       * The basename of the subjects log file that Groningen will parse as input
       * </pre>
       */
      public Builder setInputLogNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        inputLogName_ = value;
        onChanged();
        return this;
      }

      // optional int32 duration = 2 [default = 1440];
      private int duration_ = 1440;
      /**
       * <code>optional int32 duration = 2 [default = 1440];</code>
       *
       * <pre>
       * time in minutes that the experiments run in production
       * </pre>
       */
      public boolean hasDuration() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional int32 duration = 2 [default = 1440];</code>
       *
       * <pre>
       * time in minutes that the experiments run in production
       * </pre>
       */
      public int getDuration() {
        return duration_;
      }
      /**
       * <code>optional int32 duration = 2 [default = 1440];</code>
       *
       * <pre>
       * time in minutes that the experiments run in production
       * </pre>
       */
      public Builder setDuration(int value) {
        bitField0_ |= 0x00000002;
        duration_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 duration = 2 [default = 1440];</code>
       *
       * <pre>
       * time in minutes that the experiments run in production
       * </pre>
       */
      public Builder clearDuration() {
        bitField0_ = (bitField0_ & ~0x00000002);
        duration_ = 1440;
        onChanged();
        return this;
      }

      // optional int32 restart = 3 [default = 4];
      private int restart_ = 4;
      /**
       * <code>optional int32 restart = 3 [default = 4];</code>
       *
       * <pre>
       * experimental subject restart threshold used by the Executor and Validator
       * </pre>
       */
      public boolean hasRestart() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional int32 restart = 3 [default = 4];</code>
       *
       * <pre>
       * experimental subject restart threshold used by the Executor and Validator
       * </pre>
       */
      public int getRestart() {
        return restart_;
      }
      /**
       * <code>optional int32 restart = 3 [default = 4];</code>
       *
       * <pre>
       * experimental subject restart threshold used by the Executor and Validator
       * </pre>
       */
      public Builder setRestart(int value) {
        bitField0_ |= 0x00000004;
        restart_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 restart = 3 [default = 4];</code>
       *
       * <pre>
       * experimental subject restart threshold used by the Executor and Validator
       * </pre>
       */
      public Builder clearRestart() {
        bitField0_ = (bitField0_ & ~0x00000004);
        restart_ = 4;
        onChanged();
        return this;
      }

      // optional double latency_weight = 5 [default = 1];
      private double latencyWeight_ = 1D;
      /**
       * <code>optional double latency_weight = 5 [default = 1];</code>
       *
       * <pre>
       * Weight of the latency score within the hypothesizer
       * </pre>
       */
      public boolean hasLatencyWeight() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional double latency_weight = 5 [default = 1];</code>
       *
       * <pre>
       * Weight of the latency score within the hypothesizer
       * </pre>
       */
      public double getLatencyWeight() {
        return latencyWeight_;
      }
      /**
       * <code>optional double latency_weight = 5 [default = 1];</code>
       *
       * <pre>
       * Weight of the latency score within the hypothesizer
       * </pre>
       */
      public Builder setLatencyWeight(double value) {
        bitField0_ |= 0x00000008;
        latencyWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double latency_weight = 5 [default = 1];</code>
       *
       * <pre>
       * Weight of the latency score within the hypothesizer
       * </pre>
       */
      public Builder clearLatencyWeight() {
        bitField0_ = (bitField0_ & ~0x00000008);
        latencyWeight_ = 1D;
        onChanged();
        return this;
      }

      // optional double throughput_weight = 6 [default = 1];
      private double throughputWeight_ = 1D;
      /**
       * <code>optional double throughput_weight = 6 [default = 1];</code>
       *
       * <pre>
       * Weight of the throughput score within the hypothesizer
       * </pre>
       */
      public boolean hasThroughputWeight() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional double throughput_weight = 6 [default = 1];</code>
       *
       * <pre>
       * Weight of the throughput score within the hypothesizer
       * </pre>
       */
      public double getThroughputWeight() {
        return throughputWeight_;
      }
      /**
       * <code>optional double throughput_weight = 6 [default = 1];</code>
       *
       * <pre>
       * Weight of the throughput score within the hypothesizer
       * </pre>
       */
      public Builder setThroughputWeight(double value) {
        bitField0_ |= 0x00000010;
        throughputWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double throughput_weight = 6 [default = 1];</code>
       *
       * <pre>
       * Weight of the throughput score within the hypothesizer
       * </pre>
       */
      public Builder clearThroughputWeight() {
        bitField0_ = (bitField0_ & ~0x00000010);
        throughputWeight_ = 1D;
        onChanged();
        return this;
      }

      // optional double memory_weight = 8 [default = 1];
      private double memoryWeight_ = 1D;
      /**
       * <code>optional double memory_weight = 8 [default = 1];</code>
       *
       * <pre>
       * Weight of the memory score within the hypothesizer
       * </pre>
       */
      public boolean hasMemoryWeight() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional double memory_weight = 8 [default = 1];</code>
       *
       * <pre>
       * Weight of the memory score within the hypothesizer
       * </pre>
       */
      public double getMemoryWeight() {
        return memoryWeight_;
      }
      /**
       * <code>optional double memory_weight = 8 [default = 1];</code>
       *
       * <pre>
       * Weight of the memory score within the hypothesizer
       * </pre>
       */
      public Builder setMemoryWeight(double value) {
        bitField0_ |= 0x00000020;
        memoryWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double memory_weight = 8 [default = 1];</code>
       *
       * <pre>
       * Weight of the memory score within the hypothesizer
       * </pre>
       */
      public Builder clearMemoryWeight() {
        bitField0_ = (bitField0_ & ~0x00000020);
        memoryWeight_ = 1D;
        onChanged();
        return this;
      }

      // optional int32 num_crossovers = 9 [default = 1];
      private int numCrossovers_ = 1;
      /**
       * <code>optional int32 num_crossovers = 9 [default = 1];</code>
       *
       * <pre>
       * Number cross-over points for mating within hypothesizer
       * </pre>
       */
      public boolean hasNumCrossovers() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional int32 num_crossovers = 9 [default = 1];</code>
       *
       * <pre>
       * Number cross-over points for mating within hypothesizer
       * </pre>
       */
      public int getNumCrossovers() {
        return numCrossovers_;
      }
      /**
       * <code>optional int32 num_crossovers = 9 [default = 1];</code>
       *
       * <pre>
       * Number cross-over points for mating within hypothesizer
       * </pre>
       */
      public Builder setNumCrossovers(int value) {
        bitField0_ |= 0x00000040;
        numCrossovers_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 num_crossovers = 9 [default = 1];</code>
       *
       * <pre>
       * Number cross-over points for mating within hypothesizer
       * </pre>
       */
      public Builder clearNumCrossovers() {
        bitField0_ = (bitField0_ & ~0x00000040);
        numCrossovers_ = 1;
        onChanged();
        return this;
      }

      // optional double mutation_prob = 10 [default = 0.02];
      private double mutationProb_ = 0.02D;
      /**
       * <code>optional double mutation_prob = 10 [default = 0.02];</code>
       *
       * <pre>
       * Mutation probability for the offsprings
       * </pre>
       */
      public boolean hasMutationProb() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional double mutation_prob = 10 [default = 0.02];</code>
       *
       * <pre>
       * Mutation probability for the offsprings
       * </pre>
       */
      public double getMutationProb() {
        return mutationProb_;
      }
      /**
       * <code>optional double mutation_prob = 10 [default = 0.02];</code>
       *
       * <pre>
       * Mutation probability for the offsprings
       * </pre>
       */
      public Builder setMutationProb(double value) {
        bitField0_ |= 0x00000080;
        mutationProb_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double mutation_prob = 10 [default = 0.02];</code>
       *
       * <pre>
       * Mutation probability for the offsprings
       * </pre>
       */
      public Builder clearMutationProb() {
        bitField0_ = (bitField0_ & ~0x00000080);
        mutationProb_ = 0.02D;
        onChanged();
        return this;
      }

      // optional int32 stagnant_gens = 11 [default = 0];
      private int stagnantGens_ ;
      /**
       * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
       *
       * <pre>
       * Number of stagnant generations before GA terminates. The value 0 disables
       * this termination condition check.
       * </pre>
       */
      public boolean hasStagnantGens() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
       *
       * <pre>
       * Number of stagnant generations before GA terminates. The value 0 disables
       * this termination condition check.
       * </pre>
       */
      public int getStagnantGens() {
        return stagnantGens_;
      }
      /**
       * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
       *
       * <pre>
       * Number of stagnant generations before GA terminates. The value 0 disables
       * this termination condition check.
       * </pre>
       */
      public Builder setStagnantGens(int value) {
        bitField0_ |= 0x00000100;
        stagnantGens_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 stagnant_gens = 11 [default = 0];</code>
       *
       * <pre>
       * Number of stagnant generations before GA terminates. The value 0 disables
       * this termination condition check.
       * </pre>
       */
      public Builder clearStagnantGens() {
        bitField0_ = (bitField0_ & ~0x00000100);
        stagnantGens_ = 0;
        onChanged();
        return this;
      }

      // optional int32 elite_count = 12 [default = 1];
      private int eliteCount_ = 1;
      /**
       * <code>optional int32 elite_count = 12 [default = 1];</code>
       *
       * <pre>
       * Number of elite individuals in the populations for the
       *  IncrementalEvolutionEngine
       * NOTE: is not updated after the initial pass through the loop.
       * </pre>
       */
      public boolean hasEliteCount() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional int32 elite_count = 12 [default = 1];</code>
       *
       * <pre>
       * Number of elite individuals in the populations for the
       *  IncrementalEvolutionEngine
       * NOTE: is not updated after the initial pass through the loop.
       * </pre>
       */
      public int getEliteCount() {
        return eliteCount_;
      }
      /**
       * <code>optional int32 elite_count = 12 [default = 1];</code>
       *
       * <pre>
       * Number of elite individuals in the populations for the
       *  IncrementalEvolutionEngine
       * NOTE: is not updated after the initial pass through the loop.
       * </pre>
       */
      public Builder setEliteCount(int value) {
        bitField0_ |= 0x00000200;
        eliteCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 elite_count = 12 [default = 1];</code>
       *
       * <pre>
       * Number of elite individuals in the populations for the
       *  IncrementalEvolutionEngine
       * NOTE: is not updated after the initial pass through the loop.
       * </pre>
       */
      public Builder clearEliteCount() {
        bitField0_ = (bitField0_ & ~0x00000200);
        eliteCount_ = 1;
        onChanged();
        return this;
      }

      // optional double pause_time_latency_score_percentile = 13 [default = 99];
      private double pauseTimeLatencyScorePercentile_ = 99D;
      /**
       * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
       *
       * <pre>
       * The percentile used to compute the latency score (A value from 0 to 100)
       * </pre>
       */
      public boolean hasPauseTimeLatencyScorePercentile() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
       *
       * <pre>
       * The percentile used to compute the latency score (A value from 0 to 100)
       * </pre>
       */
      public double getPauseTimeLatencyScorePercentile() {
        return pauseTimeLatencyScorePercentile_;
      }
      /**
       * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
       *
       * <pre>
       * The percentile used to compute the latency score (A value from 0 to 100)
       * </pre>
       */
      public Builder setPauseTimeLatencyScorePercentile(double value) {
        bitField0_ |= 0x00000400;
        pauseTimeLatencyScorePercentile_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional double pause_time_latency_score_percentile = 13 [default = 99];</code>
       *
       * <pre>
       * The percentile used to compute the latency score (A value from 0 to 100)
       * </pre>
       */
      public Builder clearPauseTimeLatencyScorePercentile() {
        bitField0_ = (bitField0_ & ~0x00000400);
        pauseTimeLatencyScorePercentile_ = 99D;
        onChanged();
        return this;
      }

      // optional int32 number_of_executor_threads = 14 [default = 3];
      private int numberOfExecutorThreads_ = 3;
      /**
       * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
       *
       * <pre>
       * The number of threads that the Executor uses to monitor experimental
       * subjects.  Quite likely, you'll want to increase this as you increase the
       * total number of subjects in your experiment. Less threads probably implies
       * alonger period of time between sucessive probes of a given experimental
       * subject.
       * </pre>
       */
      public boolean hasNumberOfExecutorThreads() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
       *
       * <pre>
       * The number of threads that the Executor uses to monitor experimental
       * subjects.  Quite likely, you'll want to increase this as you increase the
       * total number of subjects in your experiment. Less threads probably implies
       * alonger period of time between sucessive probes of a given experimental
       * subject.
       * </pre>
       */
      public int getNumberOfExecutorThreads() {
        return numberOfExecutorThreads_;
      }
      /**
       * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
       *
       * <pre>
       * The number of threads that the Executor uses to monitor experimental
       * subjects.  Quite likely, you'll want to increase this as you increase the
       * total number of subjects in your experiment. Less threads probably implies
       * alonger period of time between sucessive probes of a given experimental
       * subject.
       * </pre>
       */
      public Builder setNumberOfExecutorThreads(int value) {
        bitField0_ |= 0x00000800;
        numberOfExecutorThreads_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 number_of_executor_threads = 14 [default = 3];</code>
       *
       * <pre>
       * The number of threads that the Executor uses to monitor experimental
       * subjects.  Quite likely, you'll want to increase this as you increase the
       * total number of subjects in your experiment. Less threads probably implies
       * alonger period of time between sucessive probes of a given experimental
       * subject.
       * </pre>
       */
      public Builder clearNumberOfExecutorThreads() {
        bitField0_ = (bitField0_ & ~0x00000800);
        numberOfExecutorThreads_ = 3;
        onChanged();
        return this;
      }

      // optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];
      private org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode pipelineSyncType_ = org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode.NONE;
      /**
       * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
       */
      public boolean hasPipelineSyncType() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
       */
      public org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode getPipelineSyncType() {
        return pipelineSyncType_;
      }
      /**
       * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
       */
      public Builder setPipelineSyncType(org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00001000;
        pipelineSyncType_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .org.arbeitspferde.groningen.proto.GroningenParams.PipelineSynchMode pipeline_sync_type = 15 [default = NONE];</code>
       */
      public Builder clearPipelineSyncType() {
        bitField0_ = (bitField0_ & ~0x00001000);
        pipelineSyncType_ = org.arbeitspferde.groningen.proto.Params.GroningenParams.PipelineSynchMode.NONE;
        onChanged();
        return this;
      }

      // optional int32 health_check_timeout = 16 [default = 30000];
      private int healthCheckTimeout_ = 30000;
      /**
       * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
       *
       * <pre>
       * How long we wait for a health check check
       * </pre>
       */
      public boolean hasHealthCheckTimeout() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
       *
       * <pre>
       * How long we wait for a health check check
       * </pre>
       */
      public int getHealthCheckTimeout() {
        return healthCheckTimeout_;
      }
      /**
       * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
       *
       * <pre>
       * How long we wait for a health check check
       * </pre>
       */
      public Builder setHealthCheckTimeout(int value) {
        bitField0_ |= 0x00002000;
        healthCheckTimeout_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 health_check_timeout = 16 [default = 30000];</code>
       *
       * <pre>
       * How long we wait for a health check check
       * </pre>
       */
      public Builder clearHealthCheckTimeout() {
        bitField0_ = (bitField0_ & ~0x00002000);
        healthCheckTimeout_ = 30000;
        onChanged();
        return this;
      }

      // optional int32 health_check_poll_interval = 17 [default = 5000];
      private int healthCheckPollInterval_ = 5000;
      /**
       * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
       *
       * <pre>
       * How long we sleep between health checks.
       * </pre>
       */
      public boolean hasHealthCheckPollInterval() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
       *
       * <pre>
       * How long we sleep between health checks.
       * </pre>
       */
      public int getHealthCheckPollInterval() {
        return healthCheckPollInterval_;
      }
      /**
       * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
       *
       * <pre>
       * How long we sleep between health checks.
       * </pre>
       */
      public Builder setHealthCheckPollInterval(int value) {
        bitField0_ |= 0x00004000;
        healthCheckPollInterval_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 health_check_poll_interval = 17 [default = 5000];</code>
       *
       * <pre>
       * How long we sleep between health checks.
       * </pre>
       */
      public Builder clearHealthCheckPollInterval() {
        bitField0_ = (bitField0_ & ~0x00004000);
        healthCheckPollInterval_ = 5000;
        onChanged();
        return this;
      }

      // optional string health_check_server_type = 18 [default = ""];
      private java.lang.Object healthCheckServerType_ = "";
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public boolean hasHealthCheckServerType() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public java.lang.String getHealthCheckServerType() {
        java.lang.Object ref = healthCheckServerType_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          healthCheckServerType_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getHealthCheckServerTypeBytes() {
        java.lang.Object ref = healthCheckServerType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          healthCheckServerType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public Builder setHealthCheckServerType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        healthCheckServerType_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public Builder clearHealthCheckServerType() {
        bitField0_ = (bitField0_ & ~0x00008000);
        healthCheckServerType_ = getDefaultInstance().getHealthCheckServerType();
        onChanged();
        return this;
      }
      /**
       * <code>optional string health_check_server_type = 18 [default = ""];</code>
       *
       * <pre>
       * The type of server that is supposed to be registered at the recipient end.
       * </pre>
       */
      public Builder setHealthCheckServerTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        healthCheckServerType_ = value;
        onChanged();
        return this;
      }

      // optional int32 metric_query_deadline_secs = 19 [default = 3];
      private int metricQueryDeadlineSecs_ = 3;
      /**
       * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
       *
       * <pre>
       * The default deadline in seconds for metric queries.
       * </pre>
       */
      public boolean hasMetricQueryDeadlineSecs() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
       *
       * <pre>
       * The default deadline in seconds for metric queries.
       * </pre>
       */
      public int getMetricQueryDeadlineSecs() {
        return metricQueryDeadlineSecs_;
      }
      /**
       * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
       *
       * <pre>
       * The default deadline in seconds for metric queries.
       * </pre>
       */
      public Builder setMetricQueryDeadlineSecs(int value) {
        bitField0_ |= 0x00010000;
        metricQueryDeadlineSecs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 metric_query_deadline_secs = 19 [default = 3];</code>
       *
       * <pre>
       * The default deadline in seconds for metric queries.
       * </pre>
       */
      public Builder clearMetricQueryDeadlineSecs() {
        bitField0_ = (bitField0_ & ~0x00010000);
        metricQueryDeadlineSecs_ = 3;
        onChanged();
        return this;
      }

      // optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];
      private int metricQueryChannelShutdownDelaySecs_ = 3;
      /**
       * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
       *
       * <pre>
       * The default channel TTL in seconds for metric query channel.
       * </pre>
       */
      public boolean hasMetricQueryChannelShutdownDelaySecs() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
       *
       * <pre>
       * The default channel TTL in seconds for metric query channel.
       * </pre>
       */
      public int getMetricQueryChannelShutdownDelaySecs() {
        return metricQueryChannelShutdownDelaySecs_;
      }
      /**
       * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
       *
       * <pre>
       * The default channel TTL in seconds for metric query channel.
       * </pre>
       */
      public Builder setMetricQueryChannelShutdownDelaySecs(int value) {
        bitField0_ |= 0x00020000;
        metricQueryChannelShutdownDelaySecs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 metric_query_channel_shutdown_delay_secs = 20 [default = 3];</code>
       *
       * <pre>
       * The default channel TTL in seconds for metric query channel.
       * </pre>
       */
      public Builder clearMetricQueryChannelShutdownDelaySecs() {
        bitField0_ = (bitField0_ & ~0x00020000);
        metricQueryChannelShutdownDelaySecs_ = 3;
        onChanged();
        return this;
      }

      // optional int32 metric_query_retry_maximum_count = 21 [default = 3];
      private int metricQueryRetryMaximumCount_ = 3;
      /**
       * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
       *
       * <pre>
       * The maximum number of times the metric query pipeline will attempt to query.
       * </pre>
       */
      public boolean hasMetricQueryRetryMaximumCount() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
       *
       * <pre>
       * The maximum number of times the metric query pipeline will attempt to query.
       * </pre>
       */
      public int getMetricQueryRetryMaximumCount() {
        return metricQueryRetryMaximumCount_;
      }
      /**
       * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
       *
       * <pre>
       * The maximum number of times the metric query pipeline will attempt to query.
       * </pre>
       */
      public Builder setMetricQueryRetryMaximumCount(int value) {
        bitField0_ |= 0x00040000;
        metricQueryRetryMaximumCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 metric_query_retry_maximum_count = 21 [default = 3];</code>
       *
       * <pre>
       * The maximum number of times the metric query pipeline will attempt to query.
       * </pre>
       */
      public Builder clearMetricQueryRetryMaximumCount() {
        bitField0_ = (bitField0_ & ~0x00040000);
        metricQueryRetryMaximumCount_ = 3;
        onChanged();
        return this;
      }

      // optional int32 metric_query_retry_delay_secs = 22 [default = 2];
      private int metricQueryRetryDelaySecs_ = 2;
      /**
       * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
       *
       * <pre>
       * The initial delay in seconds between retries for metric query failures.
       * </pre>
       */
      public boolean hasMetricQueryRetryDelaySecs() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
       *
       * <pre>
       * The initial delay in seconds between retries for metric query failures.
       * </pre>
       */
      public int getMetricQueryRetryDelaySecs() {
        return metricQueryRetryDelaySecs_;
      }
      /**
       * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
       *
       * <pre>
       * The initial delay in seconds between retries for metric query failures.
       * </pre>
       */
      public Builder setMetricQueryRetryDelaySecs(int value) {
        bitField0_ |= 0x00080000;
        metricQueryRetryDelaySecs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 metric_query_retry_delay_secs = 22 [default = 2];</code>
       *
       * <pre>
       * The initial delay in seconds between retries for metric query failures.
       * </pre>
       */
      public Builder clearMetricQueryRetryDelaySecs() {
        bitField0_ = (bitField0_ & ~0x00080000);
        metricQueryRetryDelaySecs_ = 2;
        onChanged();
        return this;
      }

      // optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];
      private int executorWaitForOneSubjectRestartMs_ = 30000;
      /**
       * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
       *
       * <pre>
       * Deadline (ms) of how long to wait for a subject to restart.
       * </pre>
       */
      public boolean hasExecutorWaitForOneSubjectRestartMs() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
       *
       * <pre>
       * Deadline (ms) of how long to wait for a subject to restart.
       * </pre>
       */
      public int getExecutorWaitForOneSubjectRestartMs() {
        return executorWaitForOneSubjectRestartMs_;
      }
      /**
       * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
       *
       * <pre>
       * Deadline (ms) of how long to wait for a subject to restart.
       * </pre>
       */
      public Builder setExecutorWaitForOneSubjectRestartMs(int value) {
        bitField0_ |= 0x00100000;
        executorWaitForOneSubjectRestartMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 executor_wait_for_one_subject_restart_ms = 23 [default = 30000];</code>
       *
       * <pre>
       * Deadline (ms) of how long to wait for a subject to restart.
       * </pre>
       */
      public Builder clearExecutorWaitForOneSubjectRestartMs() {
        bitField0_ = (bitField0_ & ~0x00100000);
        executorWaitForOneSubjectRestartMs_ = 30000;
        onChanged();
        return this;
      }

      // optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];
      private int executorSleepBtwnPollingMetricsMs_ = 60000;
      /**
       * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
       *
       * <pre>
       * Interval (ms) we wait between an iteration of polling subjects
       * </pre>
       */
      public boolean hasExecutorSleepBtwnPollingMetricsMs() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
       *
       * <pre>
       * Interval (ms) we wait between an iteration of polling subjects
       * </pre>
       */
      public int getExecutorSleepBtwnPollingMetricsMs() {
        return executorSleepBtwnPollingMetricsMs_;
      }
      /**
       * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
       *
       * <pre>
       * Interval (ms) we wait between an iteration of polling subjects
       * </pre>
       */
      public Builder setExecutorSleepBtwnPollingMetricsMs(int value) {
        bitField0_ |= 0x00200000;
        executorSleepBtwnPollingMetricsMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 executor_sleep_btwn_polling_metrics_ms = 24 [default = 60000];</code>
       *
       * <pre>
       * Interval (ms) we wait between an iteration of polling subjects
       * </pre>
       */
      public Builder clearExecutorSleepBtwnPollingMetricsMs() {
        bitField0_ = (bitField0_ & ~0x00200000);
        executorSleepBtwnPollingMetricsMs_ = 60000;
        onChanged();
        return this;
      }

      // optional int32 extractor_number_of_extractor_threads = 25 [default = 10];
      private int extractorNumberOfExtractorThreads_ = 10;
      /**
       * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
       *
       * <pre>
       * The number of extractor threads.
       * </pre>
       */
      public boolean hasExtractorNumberOfExtractorThreads() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
       *
       * <pre>
       * The number of extractor threads.
       * </pre>
       */
      public int getExtractorNumberOfExtractorThreads() {
        return extractorNumberOfExtractorThreads_;
      }
      /**
       * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
       *
       * <pre>
       * The number of extractor threads.
       * </pre>
       */
      public Builder setExtractorNumberOfExtractorThreads(int value) {
        bitField0_ |= 0x00400000;
        extractorNumberOfExtractorThreads_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 extractor_number_of_extractor_threads = 25 [default = 10];</code>
       *
       * <pre>
       * The number of extractor threads.
       * </pre>
       */
      public Builder clearExtractorNumberOfExtractorThreads() {
        bitField0_ = (bitField0_ & ~0x00400000);
        extractorNumberOfExtractorThreads_ = 10;
        onChanged();
        return this;
      }

      // optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];
      private int maximumInflightSubjectRestartCount_ = 1;
      /**
       * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
       *
       * <pre>
       * Maximum number of subjects to restart at once.
       * </pre>
       */
      public boolean hasMaximumInflightSubjectRestartCount() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
       *
       * <pre>
       * Maximum number of subjects to restart at once.
       * </pre>
       */
      public int getMaximumInflightSubjectRestartCount() {
        return maximumInflightSubjectRestartCount_;
      }
      /**
       * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
       *
       * <pre>
       * Maximum number of subjects to restart at once.
       * </pre>
       */
      public Builder setMaximumInflightSubjectRestartCount(int value) {
        bitField0_ |= 0x00800000;
        maximumInflightSubjectRestartCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 maximum_inflight_subject_restart_count = 26 [default = 1];</code>
       *
       * <pre>
       * Maximum number of subjects to restart at once.
       * </pre>
       */
      public Builder clearMaximumInflightSubjectRestartCount() {
        bitField0_ = (bitField0_ & ~0x00800000);
        maximumInflightSubjectRestartCount_ = 1;
        onChanged();
        return this;
      }

      // optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];
      private int subjectManipulationDeadlineMs_ = 30000;
      /**
       * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
       *
       * <pre>
       * The deadline (ms) for subject manipulation to occur.
       * </pre>
       */
      public boolean hasSubjectManipulationDeadlineMs() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
       *
       * <pre>
       * The deadline (ms) for subject manipulation to occur.
       * </pre>
       */
      public int getSubjectManipulationDeadlineMs() {
        return subjectManipulationDeadlineMs_;
      }
      /**
       * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
       *
       * <pre>
       * The deadline (ms) for subject manipulation to occur.
       * </pre>
       */
      public Builder setSubjectManipulationDeadlineMs(int value) {
        bitField0_ |= 0x01000000;
        subjectManipulationDeadlineMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 subject_manipulation_deadline_ms = 27 [default = 30000];</code>
       *
       * <pre>
       * The deadline (ms) for subject manipulation to occur.
       * </pre>
       */
      public Builder clearSubjectManipulationDeadlineMs() {
        bitField0_ = (bitField0_ & ~0x01000000);
        subjectManipulationDeadlineMs_ = 30000;
        onChanged();
        return this;
      }

      // optional string checkpoint_file = 28 [default = ""];
      private java.lang.Object checkpointFile_ = "";
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public boolean hasCheckpointFile() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public java.lang.String getCheckpointFile() {
        java.lang.Object ref = checkpointFile_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          checkpointFile_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getCheckpointFileBytes() {
        java.lang.Object ref = checkpointFile_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          checkpointFile_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public Builder setCheckpointFile(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x02000000;
        checkpointFile_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public Builder clearCheckpointFile() {
        bitField0_ = (bitField0_ & ~0x02000000);
        checkpointFile_ = getDefaultInstance().getCheckpointFile();
        onChanged();
        return this;
      }
      /**
       * <code>optional string checkpoint_file = 28 [default = ""];</code>
       *
       * <pre>
       * File that contains the last experiment.
       * </pre>
       */
      public Builder setCheckpointFileBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x02000000;
        checkpointFile_ = value;
        onChanged();
        return this;
      }

      // optional int32 default_in_memory_cache_ttl = 29 [default = 600000];
      private int defaultInMemoryCacheTtl_ = 600000;
      /**
       * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
       *
       * <pre>
       * The maximum TTL in seconds for objects in the memory-sensitive caches.
       * </pre>
       */
      public boolean hasDefaultInMemoryCacheTtl() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
       *
       * <pre>
       * The maximum TTL in seconds for objects in the memory-sensitive caches.
       * </pre>
       */
      public int getDefaultInMemoryCacheTtl() {
        return defaultInMemoryCacheTtl_;
      }
      /**
       * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
       *
       * <pre>
       * The maximum TTL in seconds for objects in the memory-sensitive caches.
       * </pre>
       */
      public Builder setDefaultInMemoryCacheTtl(int value) {
        bitField0_ |= 0x04000000;
        defaultInMemoryCacheTtl_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 default_in_memory_cache_ttl = 29 [default = 600000];</code>
       *
       * <pre>
       * The maximum TTL in seconds for objects in the memory-sensitive caches.
       * </pre>
       */
      public Builder clearDefaultInMemoryCacheTtl() {
        bitField0_ = (bitField0_ & ~0x04000000);
        defaultInMemoryCacheTtl_ = 600000;
        onChanged();
        return this;
      }

      // optional int32 max_subjects_in_flight_fraction = 30 [default = 3];
      private int maxSubjectsInFlightFraction_ = 3;
      /**
       * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
       *
       * <pre>
       * Divisor for max subjects in-flight for rolling subject group restart.
       * (maxInFlight = # subjects / this divisor)
       * </pre>
       */
      public boolean hasMaxSubjectsInFlightFraction() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
       *
       * <pre>
       * Divisor for max subjects in-flight for rolling subject group restart.
       * (maxInFlight = # subjects / this divisor)
       * </pre>
       */
      public int getMaxSubjectsInFlightFraction() {
        return maxSubjectsInFlightFraction_;
      }
      /**
       * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
       *
       * <pre>
       * Divisor for max subjects in-flight for rolling subject group restart.
       * (maxInFlight = # subjects / this divisor)
       * </pre>
       */
      public Builder setMaxSubjectsInFlightFraction(int value) {
        bitField0_ |= 0x08000000;
        maxSubjectsInFlightFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 max_subjects_in_flight_fraction = 30 [default = 3];</code>
       *
       * <pre>
       * Divisor for max subjects in-flight for rolling subject group restart.
       * (maxInFlight = # subjects / this divisor)
       * </pre>
       */
      public Builder clearMaxSubjectsInFlightFraction() {
        bitField0_ = (bitField0_ & ~0x08000000);
        maxSubjectsInFlightFraction_ = 3;
        onChanged();
        return this;
      }

      // optional int32 subject_group_number_of_shuffles = 31 [default = 8];
      private int subjectGroupNumberOfShuffles_ = 8;
      /**
       * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
       *
       * <pre>
       * The number of times to shuffle the subjects.
       * </pre>
       */
      public boolean hasSubjectGroupNumberOfShuffles() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
       *
       * <pre>
       * The number of times to shuffle the subjects.
       * </pre>
       */
      public int getSubjectGroupNumberOfShuffles() {
        return subjectGroupNumberOfShuffles_;
      }
      /**
       * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
       *
       * <pre>
       * The number of times to shuffle the subjects.
       * </pre>
       */
      public Builder setSubjectGroupNumberOfShuffles(int value) {
        bitField0_ |= 0x10000000;
        subjectGroupNumberOfShuffles_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 subject_group_number_of_shuffles = 31 [default = 8];</code>
       *
       * <pre>
       * The number of times to shuffle the subjects.
       * </pre>
       */
      public Builder clearSubjectGroupNumberOfShuffles() {
        bitField0_ = (bitField0_ & ~0x10000000);
        subjectGroupNumberOfShuffles_ = 8;
        onChanged();
        return this;
      }

      // optional int32 subjects_to_display = 32 [default = 5];
      private int subjectsToDisplay_ = 5;
      /**
       * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
       *
       * <pre>
       * The number of subjects to display in Groningen's HUD.
       * </pre>
       */
      public boolean hasSubjectsToDisplay() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
       *
       * <pre>
       * The number of subjects to display in Groningen's HUD.
       * </pre>
       */
      public int getSubjectsToDisplay() {
        return subjectsToDisplay_;
      }
      /**
       * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
       *
       * <pre>
       * The number of subjects to display in Groningen's HUD.
       * </pre>
       */
      public Builder setSubjectsToDisplay(int value) {
        bitField0_ |= 0x20000000;
        subjectsToDisplay_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 subjects_to_display = 32 [default = 5];</code>
       *
       * <pre>
       * The number of subjects to display in Groningen's HUD.
       * </pre>
       */
      public Builder clearSubjectsToDisplay() {
        bitField0_ = (bitField0_ & ~0x20000000);
        subjectsToDisplay_ = 5;
        onChanged();
        return this;
      }

      // optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];
      private java.lang.Object eventLogPrefix_ = "alloc/logs/tmp-groningen_events";
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public boolean hasEventLogPrefix() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public java.lang.String getEventLogPrefix() {
        java.lang.Object ref = eventLogPrefix_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          eventLogPrefix_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getEventLogPrefixBytes() {
        java.lang.Object ref = eventLogPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          eventLogPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public Builder setEventLogPrefix(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x40000000;
        eventLogPrefix_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public Builder clearEventLogPrefix() {
        bitField0_ = (bitField0_ & ~0x40000000);
        eventLogPrefix_ = getDefaultInstance().getEventLogPrefix();
        onChanged();
        return this;
      }
      /**
       * <code>optional string event_log_prefix = 33 [default = "alloc/logs/tmp-groningen_events"];</code>
       *
       * <pre>
       * The path along with base string prefix for the Groningen event log.
       * </pre>
       */
      public Builder setEventLogPrefixBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x40000000;
        eventLogPrefix_ = value;
        onChanged();
        return this;
      }

      // optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];
      private int eventLogRotateSizeBytes_ = 524288000;
      /**
       * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
       *
       * <pre>
       * The quantity in bytes that the Groningen event log may grow before being
       * rotated.
       * </pre>
       */
      public boolean hasEventLogRotateSizeBytes() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
       *
       * <pre>
       * The quantity in bytes that the Groningen event log may grow before being
       * rotated.
       * </pre>
       */
      public int getEventLogRotateSizeBytes() {
        return eventLogRotateSizeBytes_;
      }
      /**
       * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
       *
       * <pre>
       * The quantity in bytes that the Groningen event log may grow before being
       * rotated.
       * </pre>
       */
      public Builder setEventLogRotateSizeBytes(int value) {
        bitField0_ |= 0x80000000;
        eventLogRotateSizeBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 event_log_rotate_size_bytes = 34 [default = 524288000];</code>
       *
       * <pre>
       * The quantity in bytes that the Groningen event log may grow before being
       * rotated.
       * </pre>
       */
      public Builder clearEventLogRotateSizeBytes() {
        bitField0_ = (bitField0_ & ~0x80000000);
        eventLogRotateSizeBytes_ = 524288000;
        onChanged();
        return this;
      }

      // optional int32 event_log_flush_interval_secs = 35 [default = 60];
      private int eventLogFlushIntervalSecs_ = 60;
      /**
       * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
       *
       * <pre>
       * The number of seconds that may transpire between Groningen event log
       * flushing.
       * </pre>
       */
      public boolean hasEventLogFlushIntervalSecs() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
       *
       * <pre>
       * The number of seconds that may transpire between Groningen event log
       * flushing.
       * </pre>
       */
      public int getEventLogFlushIntervalSecs() {
        return eventLogFlushIntervalSecs_;
      }
      /**
       * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
       *
       * <pre>
       * The number of seconds that may transpire between Groningen event log
       * flushing.
       * </pre>
       */
      public Builder setEventLogFlushIntervalSecs(int value) {
        bitField1_ |= 0x00000001;
        eventLogFlushIntervalSecs_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 event_log_flush_interval_secs = 35 [default = 60];</code>
       *
       * <pre>
       * The number of seconds that may transpire between Groningen event log
       * flushing.
       * </pre>
       */
      public Builder clearEventLogFlushIntervalSecs() {
        bitField1_ = (bitField1_ & ~0x00000001);
        eventLogFlushIntervalSecs_ = 60;
        onChanged();
        return this;
      }

      // optional string additional_exec_paths = 36 [default = ""];
      private java.lang.Object additionalExecPaths_ = "";
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public boolean hasAdditionalExecPaths() {
        return ((bitField1_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public java.lang.String getAdditionalExecPaths() {
        java.lang.Object ref = additionalExecPaths_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          additionalExecPaths_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getAdditionalExecPathsBytes() {
        java.lang.Object ref = additionalExecPaths_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          additionalExecPaths_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public Builder setAdditionalExecPaths(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000002;
        additionalExecPaths_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public Builder clearAdditionalExecPaths() {
        bitField1_ = (bitField1_ & ~0x00000002);
        additionalExecPaths_ = getDefaultInstance().getAdditionalExecPaths();
        onChanged();
        return this;
      }
      /**
       * <code>optional string additional_exec_paths = 36 [default = ""];</code>
       *
       * <pre>
       * Additional paths where executable permissions will be set when running
       * experiments.
       * </pre>
       */
      public Builder setAdditionalExecPathsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000002;
        additionalExecPaths_ = value;
        onChanged();
        return this;
      }

      // optional string requested_pipeline_id = 37;
      private java.lang.Object requestedPipelineId_ = "";
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public boolean hasRequestedPipelineId() {
        return ((bitField1_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public java.lang.String getRequestedPipelineId() {
        java.lang.Object ref = requestedPipelineId_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          requestedPipelineId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getRequestedPipelineIdBytes() {
        java.lang.Object ref = requestedPipelineId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          requestedPipelineId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public Builder setRequestedPipelineId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000004;
        requestedPipelineId_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public Builder clearRequestedPipelineId() {
        bitField1_ = (bitField1_ & ~0x00000004);
        requestedPipelineId_ = getDefaultInstance().getRequestedPipelineId();
        onChanged();
        return this;
      }
      /**
       * <code>optional string requested_pipeline_id = 37;</code>
       *
       * <pre>
       * Request specific pipeline ID, otherwise it will be auto generated.
       * </pre>
       */
      public Builder setRequestedPipelineIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000004;
        requestedPipelineId_ = value;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:org.arbeitspferde.groningen.proto.GroningenParams)
    }

    static {
      defaultInstance = new GroningenParams(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:org.arbeitspferde.groningen.proto.GroningenParams)
  }

  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_org_arbeitspferde_groningen_proto_GroningenParams_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\014params.proto\022!org.arbeitspferde.gronin" +
      "gen.proto\"\353\013\n\017GroningenParams\022\026\n\016input_l" +
      "og_name\030\001 \001(\t\022\026\n\010duration\030\002 \001(\005:\0041440\022\022\n" +
      "\007restart\030\003 \001(\005:\0014\022\031\n\016latency_weight\030\005 \001(" +
      "\001:\0011\022\034\n\021throughput_weight\030\006 \001(\001:\0011\022\030\n\rme" +
      "mory_weight\030\010 \001(\001:\0011\022\031\n\016num_crossovers\030\t" +
      " \001(\005:\0011\022\033\n\rmutation_prob\030\n \001(\001:\0040.02\022\030\n\r" +
      "stagnant_gens\030\013 \001(\005:\0010\022\026\n\013elite_count\030\014 " +
      "\001(\005:\0011\022/\n#pause_time_latency_score_perce" +
      "ntile\030\r \001(\001:\00299\022%\n\032number_of_executor_th",
      "reads\030\016 \001(\005:\0013\022f\n\022pipeline_sync_type\030\017 \001" +
      "(\0162D.org.arbeitspferde.groningen.proto.G" +
      "roningenParams.PipelineSynchMode:\004NONE\022#" +
      "\n\024health_check_timeout\030\020 \001(\005:\00530000\022(\n\032h" +
      "ealth_check_poll_interval\030\021 \001(\005:\0045000\022\"\n" +
      "\030health_check_server_type\030\022 \001(\t:\000\022%\n\032met" +
      "ric_query_deadline_secs\030\023 \001(\005:\0013\0223\n(metr" +
      "ic_query_channel_shutdown_delay_secs\030\024 \001" +
      "(\005:\0013\022+\n metric_query_retry_maximum_coun" +
      "t\030\025 \001(\005:\0013\022(\n\035metric_query_retry_delay_s",
      "ecs\030\026 \001(\005:\0012\0227\n(executor_wait_for_one_su" +
      "bject_restart_ms\030\027 \001(\005:\00530000\0225\n&executo" +
      "r_sleep_btwn_polling_metrics_ms\030\030 \001(\005:\0056" +
      "0000\0221\n%extractor_number_of_extractor_th" +
      "reads\030\031 \001(\005:\00210\0221\n&maximum_inflight_subj" +
      "ect_restart_count\030\032 \001(\005:\0011\022/\n subject_ma" +
      "nipulation_deadline_ms\030\033 \001(\005:\00530000\022\031\n\017c" +
      "heckpoint_file\030\034 \001(\t:\000\022+\n\033default_in_mem" +
      "ory_cache_ttl\030\035 \001(\005:\006600000\022*\n\037max_subje" +
      "cts_in_flight_fraction\030\036 \001(\005:\0013\022+\n subje",
      "ct_group_number_of_shuffles\030\037 \001(\005:\0018\022\036\n\023" +
      "subjects_to_display\030  \001(\005:\0015\0229\n\020event_lo" +
      "g_prefix\030! \001(\t:\037alloc/logs/tmp-groningen" +
      "_events\022.\n\033event_log_rotate_size_bytes\030\"" +
      " \001(\005:\t524288000\022)\n\035event_log_flush_inter" +
      "val_secs\030# \001(\005:\00260\022\037\n\025additional_exec_pa" +
      "ths\030$ \001(\t:\000\022\035\n\025requested_pipeline_id\030% \001" +
      "(\t\"S\n\021PipelineSynchMode\022\010\n\004NONE\020\000\022\023\n\017BAS" +
      "IC_SEMAPHORE\020\001\022\037\n\033ITERATION_FINALIZATION" +
      "_ONLY\020\002B#\n!org.arbeitspferde.groningen.p",
      "roto"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor =
            getDescriptor().getMessageTypes().get(0);
          internal_static_org_arbeitspferde_groningen_proto_GroningenParams_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_org_arbeitspferde_groningen_proto_GroningenParams_descriptor,
              new java.lang.String[] { "InputLogName", "Duration", "Restart", "LatencyWeight", "ThroughputWeight", "MemoryWeight", "NumCrossovers", "MutationProb", "StagnantGens", "EliteCount", "PauseTimeLatencyScorePercentile", "NumberOfExecutorThreads", "PipelineSyncType", "HealthCheckTimeout", "HealthCheckPollInterval", "HealthCheckServerType", "MetricQueryDeadlineSecs", "MetricQueryChannelShutdownDelaySecs", "MetricQueryRetryMaximumCount", "MetricQueryRetryDelaySecs", "ExecutorWaitForOneSubjectRestartMs", "ExecutorSleepBtwnPollingMetricsMs", "ExtractorNumberOfExtractorThreads", "MaximumInflightSubjectRestartCount", "SubjectManipulationDeadlineMs", "CheckpointFile", "DefaultInMemoryCacheTtl", "MaxSubjectsInFlightFraction", "SubjectGroupNumberOfShuffles", "SubjectsToDisplay", "EventLogPrefix", "EventLogRotateSizeBytes", "EventLogFlushIntervalSecs", "AdditionalExecPaths", "RequestedPipelineId", });
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
